"""Meta-Agentic α-AGI Jobs V5 orchestration helpers."""

from __future__ import annotations

import json
import os
from dataclasses import dataclass
from datetime import datetime, timezone
from pathlib import Path
from textwrap import dedent
from typing import Any, Dict, Iterable, List

from meta_agentic_alpha_demo import DemoConfiguration, DemoOutcome, load_configuration, run_demo

DEMO_ROOT = Path(__file__).resolve().parents[2]
PACKAGE_ROOT = DEMO_ROOT / "meta_agentic_alpha_v5"
DEFAULT_CONFIG_PATH = PACKAGE_ROOT / "config" / "scenario.yaml"


@dataclass
class MetaConductorOutcome:
    """Composite artefacts generated by the V5 demo."""

    base: DemoOutcome
    summary_path: Path
    dashboard_path: Path
    report_path: Path
    scoreboard_path: Path
    dashboard_payload: Dict[str, Any]
    governance: "OwnerGovernanceSpec"


@dataclass(frozen=True)
class OwnerGovernanceSpec:
    """Validated governance controls ensuring the owner retains command."""

    guardians: List[str]
    approvals_required: int
    emergency_pause: bool
    can_delegate_parameters: bool
    circuit_breaker_window_minutes: int
    unstoppable_reserve_percent: float
    session_keys: List[str]
    bundler: str
    paymaster: str

    @property
    def guardian_count(self) -> int:
        return len(self.guardians)


def _validate_guardian_quorum(guardians: Iterable[str], approvals_required: int) -> None:
    guardian_list = [str(guardian) for guardian in guardians if guardian]
    if not guardian_list:
        raise ValueError("Scenario must define at least one guardian address")
    if approvals_required <= 0:
        raise ValueError("Approvals quorum must be a positive integer")
    if approvals_required > len(guardian_list):
        raise ValueError(
            "Approvals quorum cannot exceed the number of configured guardians"
        )


def validate_owner_governance(config: DemoConfiguration) -> OwnerGovernanceSpec:
    """Validate scenario governance controls and surface an owner spec."""

    scenario = config.payload.get("scenario", {})
    if not isinstance(scenario, dict):
        raise ValueError("Scenario configuration must be a mapping")

    owner = scenario.get("owner", {})
    treasury = scenario.get("treasury", {})
    gasless = scenario.get("gasless", {})

    if not isinstance(owner, dict):
        raise ValueError("Scenario owner block must be a mapping")
    if not isinstance(treasury, dict):
        raise ValueError("Scenario treasury block must be a mapping")
    if not isinstance(gasless, dict):
        raise ValueError("Scenario gasless block must be a mapping")

    guardians = owner.get("guardians", [])
    approvals_required = int(owner.get("approvals_required", 0))
    _validate_guardian_quorum(guardians, approvals_required)

    emergency_pause = bool(owner.get("emergency_pause", False))
    if not emergency_pause:
        raise ValueError("Emergency pause must be enabled for sovereign control")

    can_delegate_parameters = bool(owner.get("can_delegate_parameters", False))
    circuit_breaker_window_minutes = int(owner.get("circuit_breaker_window_minutes", 0))
    if circuit_breaker_window_minutes <= 0:
        raise ValueError("Circuit breaker window must be greater than zero minutes")

    unstoppable_reserve_percent = float(treasury.get("unstoppable_reserve_percent", 0.0))
    if unstoppable_reserve_percent <= 0:
        raise ValueError("Treasury unstoppable reserve must be configured and positive")

    session_keys = [str(key) for key in gasless.get("session_keys", []) if key]
    if not session_keys:
        raise ValueError("At least one gasless session key must be configured")

    bundler = str(gasless.get("bundler") or "").strip()
    paymaster = str(gasless.get("paymaster") or "").strip()
    if not bundler or not paymaster:
        raise ValueError("Bundler and paymaster must be specified for gasless control")

    return OwnerGovernanceSpec(
        guardians=list(guardians),
        approvals_required=approvals_required,
        emergency_pause=emergency_pause,
        can_delegate_parameters=can_delegate_parameters,
        circuit_breaker_window_minutes=circuit_breaker_window_minutes,
        unstoppable_reserve_percent=unstoppable_reserve_percent,
        session_keys=session_keys,
        bundler=bundler,
        paymaster=paymaster,
    )


def prepare_environment(demo_root: Path) -> Dict[str, Path]:
    """Prepare isolated storage directories & environment variables for V5."""

    orchestrator_root = demo_root / "storage" / "orchestrator_v5"
    orchestrator_root.mkdir(parents=True, exist_ok=True)
    (orchestrator_root / "agents").mkdir(parents=True, exist_ok=True)
    (orchestrator_root / "runs").mkdir(parents=True, exist_ok=True)

    env_map = {
        "ORCHESTRATOR_BRIDGE_MODE": "python",
        "ORCHESTRATOR_SCOREBOARD_PATH": orchestrator_root / "scoreboard.json",
        "ORCHESTRATOR_CHECKPOINT_PATH": orchestrator_root / "checkpoint.json",
        "ORCHESTRATOR_CHECKPOINT_LEVELDB": orchestrator_root / "checkpoint.db",
        "ORCHESTRATOR_GOVERNANCE_PATH": orchestrator_root / "governance.json",
        "ORCHESTRATOR_STATE_DIR": orchestrator_root / "runs",
        "AGENT_REGISTRY_PATH": orchestrator_root / "agents" / "registry.json",
    }
    for key, value in env_map.items():
        os.environ[key] = str(value)
    return env_map


def _load_json(path: Path) -> Dict[str, Any]:
    payload = json.loads(path.read_text(encoding="utf-8"))
    if not isinstance(payload, dict):
        raise ValueError(f"Expected mapping payload at {path}")
    return payload


def generate_dashboard_payload(
    package_root: Path,
    summary: Dict[str, Any],
    scoreboard: Dict[str, Any],
    governance_spec: OwnerGovernanceSpec,
) -> Dict[str, Any]:
    """Assemble dashboard data for the Sovereign Meta-Conductor console."""

    data_root = package_root / "data"
    alpha = _load_json(data_root / "alpha_signals.json")
    governance_matrix = _load_json(data_root / "governance_matrix.json")
    guardian_mesh = _load_json(data_root / "guardian_mesh.json").get("mesh", {})
    sentinels = guardian_mesh.get("sentinels", [])
    playbook = _load_json(data_root / "opportunity_playbook.json")
    timeline = _load_json(data_root / "timeline.json")

    approvals = summary.get("approvals", [])
    completed_steps = summary.get("completedSteps", 0)
    total_steps = summary.get("totalSteps", 1) or 1
    base_probability = summary.get("estimatedAlphaProbability", 0.0)

    owner_controls = sorted(
        set(playbook.get("owner_controls", []) + governance_matrix.get("human_actions", []))
    )

    owner_empowerment = min(
        1.0,
        0.45
        + 0.05 * len(owner_controls)
        + 0.1 * len(approvals)
        + (0.05 if governance_spec.emergency_pause else 0.0)
        + (0.04 if governance_spec.can_delegate_parameters else 0.0)
    )
    antifragility_index = min(
        1.0,
        (governance_matrix.get("risk_policies", {}).get("antifragility_buffer_percent", 0) / 100)
        + 0.25,
    )

    owner_levers = sorted(
        set(
            owner_controls
            + [
                "Emergency pause switch",
                f"Guardian quorum {governance_spec.approvals_required}/{governance_spec.guardian_count}",
                f"Circuit breaker {governance_spec.circuit_breaker_window_minutes} min",
                f"Unstoppable reserve {governance_spec.unstoppable_reserve_percent:.1f}%",
                f"Bundler {governance_spec.bundler}",
                f"Paymaster {governance_spec.paymaster}",
            ]
        )
    )

    control_surface_score = min(
        1.0,
        0.35
        + 0.04 * len(owner_controls)
        + 0.05 * len(governance_spec.session_keys)
        + (0.06 if governance_spec.emergency_pause else 0.0)
        + (0.05 if governance_spec.can_delegate_parameters else 0.0)
        + min(0.05, governance_spec.unstoppable_reserve_percent / 1000.0),
    )

    def _sentinel(index: int, fallback: str) -> str:
        if index < len(sentinels):
            return str(sentinels[index].get("id", fallback))
        return fallback

    mermaid_flow = dedent(
        f"""
        graph LR
          Owner((Sovereign Owner)) --> Identify
          Identify[Identify Mesh] --> Learn[World Model]
          Learn --> Plan[Meta-Agentic Planner]
          Plan --> Design[Creative Forge]
          Design --> Strategise[Treasury Optimiser]
          Strategise --> Execute[On-Chain Pipeline]
          Execute --> Owner
          subgraph Guardian Mesh
            G1[{_sentinel(0, 'guardian-grid-validator')}]
            G2[{_sentinel(1, 'mission-audit-sentinel')}]
            G3[{_sentinel(2, 'alpha-treasury-autopilot')}]
            G4[{_sentinel(3, 'sovereign-simulation-director')}]
          end
          Owner -->|Approvals {len(approvals)}/3| Guardian Mesh
        """
    ).strip()

    mermaid_sequence = dedent(
        """
        sequenceDiagram
          participant Owner as Sovereign Owner
          participant Console as Meta-Conductor Console
          participant Mesh as Guardian Mesh
          participant Treasury as Treasury Optimiser
          participant Chain as AGI Jobs v0 (v2)
          Owner->>Console: Launch V5 orchestration
          Console->>Mesh: Dispatch approvals & antifragility checks
          Mesh->>Treasury: Align unstoppable reserve + liquidity routes
          Treasury->>Chain: Simulate job.post + stake.deposit + validator.commit
          Chain-->>Console: Dry-run receipts + scoreboard signals
          Console-->>Owner: Masterplan + live controls
        """
    ).strip()

    return {
        "generated_at": datetime.now(timezone.utc).isoformat(),
        "alpha": alpha,
        "governance": governance_matrix,
        "guardian_mesh": guardian_mesh,
        "timeline": timeline,
        "owner_controls": owner_controls,
        "control_surface": {
            "score": control_surface_score,
            "guardian_quorum": governance_spec.approvals_required,
            "guardian_count": governance_spec.guardian_count,
            "emergency_pause": governance_spec.emergency_pause,
            "circuit_breaker_minutes": governance_spec.circuit_breaker_window_minutes,
            "unstoppable_reserve_percent": governance_spec.unstoppable_reserve_percent,
            "session_keys": governance_spec.session_keys,
            "bundler": governance_spec.bundler,
            "paymaster": governance_spec.paymaster,
            "levers": owner_levers,
        },
        "mermaid": {
            "flow": mermaid_flow,
            "sequence": mermaid_sequence,
        },
        "metrics": {
            "owner_empowerment": owner_empowerment,
            "antifragility_index": antifragility_index,
            "alpha_probability": base_probability,
            "step_completion_ratio": completed_steps / total_steps,
            "scoreboard": scoreboard,
            "control_surface_score": control_surface_score,
        },
    }


def generate_masterplan_report(package_root: Path, summary: Dict[str, Any], dashboard: Dict[str, Any]) -> Path:
    """Render the V5 masterplan markdown deck."""

    reports_dir = package_root / "reports" / "generated"
    reports_dir.mkdir(parents=True, exist_ok=True)
    path = reports_dir / "meta_conductor_masterplan.md"

    alpha_domains = dashboard["alpha"]["domains"]
    guardian_mesh = dashboard["guardian_mesh"].get("sentinels", [])
    controls = dashboard["governance"]["controls"]
    timeline = dashboard["timeline"]["events"]
    control_surface = dashboard["control_surface"]

    content = dedent(
        f"""
        # Sovereign Meta-Conductor Masterplan (V5)

        **Generated:** {dashboard['generated_at']} UTC

        ## Alpha Opportunity Lattice

        | Domain | Signal | Alpha Projection (USD) |
        | --- | --- | --- |
        {os.linesep.join(f"| {domain['title']} | {domain['signal_strength']*100:.1f}% | ${domain['alpha_projection']:,} |" for domain in alpha_domains)}

        ## Guardian Mesh Readiness

        | Sentinel | Capabilities | Stake | Status |
        | --- | --- | --- | --- |
        {os.linesep.join(f"| {agent['id']} | {', '.join(agent['capabilities'])} | {agent['stake']:,} AGIALPHA | {agent['status']} |" for agent in guardian_mesh)}

        ## Owner Controls at a Glance

        - Emergency pause: {"enabled" if controls['treasury']['pause_switch'] else "disabled"}
        - Owner editable treasury routes: {"yes" if controls['treasury']['owner_editable'] else "no"}
        - Session keys: {', '.join(dashboard['governance']['controls']['account_abstraction']['session_keys'])}
        - Human override actions: {', '.join(dashboard['owner_controls'])}

        ## Execution Timeline

        {os.linesep.join(f"- **{event['time']}** — {event['event']}" for event in timeline)}

        ## Alpha Probability & Antifragility

        - Alpha probability: {dashboard['metrics']['alpha_probability']*100:.2f}%
        - Step completion: {dashboard['metrics']['step_completion_ratio']*100:.2f}%
        - Antifragility index: {dashboard['metrics']['antifragility_index']*100:.2f}%
        - Owner empowerment: {dashboard['metrics']['owner_empowerment']*100:.2f}%
        - Control surface score: {dashboard['metrics']['control_surface_score']*100:.2f}%

        ## Owner Sovereignty Matrix

        | Lever | Status |
        | --- | --- |
        | Guardian quorum | {control_surface['guardian_quorum']} approvals / {control_surface['guardian_count']} guardians |
        | Emergency pause | {"armed" if control_surface['emergency_pause'] else "disabled"} |
        | Circuit breaker | {control_surface['circuit_breaker_minutes']} minute window |
        | Unstoppable reserve | {control_surface['unstoppable_reserve_percent']:.1f}% treasury buffer |
        | Bundler | {control_surface['bundler']} |
        | Paymaster | {control_surface['paymaster']} |
        | Session keys | {', '.join(control_surface['session_keys'])} |

        ### Owner Command Levers

        {os.linesep.join(f"- {lever}" for lever in control_surface['levers'])}

        ## Meta-Agentic Flow

        ```mermaid
        {dashboard['mermaid']['flow']}
        ```

        ## Guardian Coordination Sequence

        ```mermaid
        {dashboard['mermaid']['sequence']}
        ```

        ## Scoreboard Snapshot

        ```json
        {json.dumps(dashboard['metrics']['scoreboard'], indent=2)}
        ```
        """
    ).strip() + "\n"

    path.write_text(content, encoding="utf-8")
    return path


def run_meta_conductor_demo(config_path: Path | None = None, *, timeout: float = 120.0) -> MetaConductorOutcome:
    """Execute the Meta-Agentic α-AGI Jobs V5 demo end-to-end."""

    if config_path is None:
        config_path = DEFAULT_CONFIG_PATH
    config = load_configuration(config_path)
    governance_spec = validate_owner_governance(config)
    package_root = config.base_dir
    demo_root = package_root.parent

    env_map = prepare_environment(demo_root)
    outcome = run_demo(config, timeout=timeout)

    summary = json.loads(outcome.summary_path.read_text(encoding="utf-8"))
    summary["approvals"] = config.approvals
    summary["scenarioId"] = config.payload.get("scenario", {}).get("id")
    summary["agents"] = outcome.metadata.get("onboarded_agents", [])

    scoreboard_path = Path(env_map["ORCHESTRATOR_SCOREBOARD_PATH"])
    scoreboard = outcome.scoreboard_snapshot or {}

    dashboard_payload = generate_dashboard_payload(
        package_root,
        summary,
        scoreboard,
        governance_spec,
    )

    dashboard_path = package_root / "ui" / "dashboard-data-v5.json"
    dashboard_path.write_text(json.dumps(dashboard_payload, ensure_ascii=False, indent=2), encoding="utf-8")

    masterplan_path = generate_masterplan_report(package_root, summary, dashboard_payload)

    latest_run_path = demo_root / "storage" / "latest_run_v5.json"
    latest_run_path.write_text(json.dumps(summary, ensure_ascii=False, indent=2), encoding="utf-8")

    return MetaConductorOutcome(
        base=outcome,
        summary_path=latest_run_path,
        dashboard_path=dashboard_path,
        report_path=masterplan_path,
        scoreboard_path=scoreboard_path,
        dashboard_payload=dashboard_payload,
        governance=governance_spec,
    )


__all__ = [
    "DEFAULT_CONFIG_PATH",
    "OwnerGovernanceSpec",
    "MetaConductorOutcome",
    "generate_dashboard_payload",
    "generate_masterplan_report",
    "prepare_environment",
    "validate_owner_governance",
    "run_meta_conductor_demo",
]
