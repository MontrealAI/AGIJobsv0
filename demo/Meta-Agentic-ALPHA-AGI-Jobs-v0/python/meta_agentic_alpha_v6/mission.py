from __future__ import annotations

import json
import os
from dataclasses import dataclass
from datetime import datetime, timezone
from pathlib import Path
from textwrap import dedent
from typing import Any, Dict, Iterable, List, Mapping

from meta_agentic_alpha_demo import DemoConfiguration, DemoOutcome, load_configuration, run_demo

DEMO_ROOT = Path(__file__).resolve().parents[2]
PACKAGE_ROOT = DEMO_ROOT / "meta_agentic_alpha_v6"
DEFAULT_CONFIG_PATH = PACKAGE_ROOT / "config" / "scenario.yaml"


@dataclass
class OwnerCommandMatrix:
    """Validated owner empowerment profile for the V6 demo."""

    guardians: List[str]
    guardian_failover: List[str]
    approvals_required: int
    emergency_pause: bool
    antifragility_buffer_percent: float
    unstoppable_reserve_percent: float
    delegation_matrix: Mapping[str, Any]
    circuit_breaker_window_minutes: int
    session_keys: List[str]
    bundler: str
    paymaster: str
    treasury_policy: Mapping[str, Any]

    @property
    def guardian_count(self) -> int:
        return len(self.guardians)

    @property
    def total_guardians(self) -> int:
        return len(self.guardians) + len(self.guardian_failover)


@dataclass
class AlphaDominionOutcome:
    """Composite artefacts generated by the V6 demo."""

    base: DemoOutcome
    summary_path: Path
    dashboard_path: Path
    report_path: Path
    scoreboard_path: Path
    dashboard_payload: Dict[str, Any]
    command_matrix: OwnerCommandMatrix


def _validate_guardian_mesh(guardians: Iterable[str], approvals_required: int) -> List[str]:
    guardian_list = [str(address) for address in guardians if str(address).strip()]
    if not guardian_list:
        raise ValueError("Scenario must configure at least one guardian")
    if approvals_required <= 0:
        raise ValueError("Approvals quorum must be a positive integer")
    if approvals_required > len(guardian_list):
        raise ValueError("Approvals quorum cannot exceed guardian count")
    return guardian_list


def validate_owner_command(config: DemoConfiguration) -> OwnerCommandMatrix:
    """Validate the V6 scenario delivers complete owner control."""

    scenario = config.payload.get("scenario", {})
    if not isinstance(scenario, dict):
        raise ValueError("Scenario configuration must provide a `scenario` mapping")

    owner = scenario.get("owner", {})
    treasury = scenario.get("treasury", {})
    gasless = scenario.get("gasless", {})
    delegation = owner.get("delegation", {})

    if not isinstance(owner, dict):
        raise ValueError("Scenario must define an owner block")
    if not isinstance(treasury, dict):
        raise ValueError("Scenario must define treasury controls")
    if not isinstance(gasless, dict):
        raise ValueError("Scenario must define gasless/account abstraction controls")
    if not isinstance(delegation, dict):
        raise ValueError("Owner delegation block must be a mapping")

    guardians = _validate_guardian_mesh(owner.get("guardians", []), int(owner.get("approvals_required", 0)))
    guardian_failover = [
        str(address)
        for address in owner.get("guardian_failover", [])
        if str(address).strip() and str(address) not in guardians
    ]

    emergency_pause = bool(owner.get("emergency_pause", False))
    if not emergency_pause:
        raise ValueError("Emergency pause must remain enabled for V6")

    antifragility_buffer_percent = float(treasury.get("risk_limits", {}).get("antifragility_buffer_percent", 0.0))
    if antifragility_buffer_percent <= 0:
        raise ValueError("Antifragility buffer must be positive")

    unstoppable_reserve_percent = float(treasury.get("unstoppable_reserve_percent", 0.0))
    if unstoppable_reserve_percent < 15:
        raise ValueError("Unstoppable reserve must be at least 15% of treasury for V6")

    circuit_breaker_window_minutes = int(owner.get("circuit_breaker_window_minutes", 0))
    if circuit_breaker_window_minutes <= 0:
        raise ValueError("Circuit breaker window must be positive")

    session_keys = [str(key) for key in gasless.get("session_keys", []) if str(key).strip()]
    if len(session_keys) < 3:
        raise ValueError("At least three session keys must be configured")

    bundler = str(gasless.get("bundler", "")).strip()
    paymaster = str(gasless.get("paymaster", "")).strip()
    if not bundler or not paymaster:
        raise ValueError("Bundler and paymaster are required for gasless orchestration")

    return OwnerCommandMatrix(
        guardians=guardians,
        guardian_failover=guardian_failover,
        approvals_required=int(owner.get("approvals_required", 0)),
        emergency_pause=emergency_pause,
        antifragility_buffer_percent=antifragility_buffer_percent,
        unstoppable_reserve_percent=unstoppable_reserve_percent,
        delegation_matrix=delegation,
        circuit_breaker_window_minutes=circuit_breaker_window_minutes,
        session_keys=session_keys,
        bundler=bundler,
        paymaster=paymaster,
        treasury_policy=treasury,
    )


def prepare_environment(demo_root: Path) -> Dict[str, Path]:
    """Prepare isolated storage directories and env vars for V6 runs."""

    orchestrator_root = demo_root / "storage" / "orchestrator_v6"
    orchestrator_root.mkdir(parents=True, exist_ok=True)
    (orchestrator_root / "agents").mkdir(parents=True, exist_ok=True)
    (orchestrator_root / "runs").mkdir(parents=True, exist_ok=True)

    env_map = {
        "ORCHESTRATOR_BRIDGE_MODE": "python",
        "ORCHESTRATOR_SCOREBOARD_PATH": orchestrator_root / "scoreboard.json",
        "ORCHESTRATOR_CHECKPOINT_PATH": orchestrator_root / "checkpoint.json",
        "ORCHESTRATOR_CHECKPOINT_LEVELDB": orchestrator_root / "checkpoint.db",
        "ORCHESTRATOR_GOVERNANCE_PATH": orchestrator_root / "governance.json",
        "ORCHESTRATOR_STATE_DIR": orchestrator_root / "runs",
        "AGENT_REGISTRY_PATH": orchestrator_root / "agents" / "registry.json",
    }
    for key, value in env_map.items():
        os.environ[key] = str(value)
    return env_map


def _load_json(path: Path) -> Dict[str, Any]:
    payload = json.loads(path.read_text(encoding="utf-8"))
    if not isinstance(payload, dict):
        raise ValueError(f"Expected mapping payload at {path}")
    return payload


def generate_dashboard_payload(
    package_root: Path,
    summary: Dict[str, Any],
    scoreboard: Dict[str, Any],
    command: OwnerCommandMatrix,
) -> Dict[str, Any]:
    """Generate the V6 sovereign console payload."""

    data_root = package_root / "data"
    alpha = _load_json(data_root / "alpha_signals.json")
    opportunity_graph = _load_json(data_root / "opportunity_graph.json")
    governance_matrix = _load_json(data_root / "governance_matrix.json")
    guardian_mesh = _load_json(data_root / "guardian_mesh.json")
    execution_routes = _load_json(data_root / "execution_routes.json")
    simulations = _load_json(data_root / "simulation_matrix.json")
    timeline = _load_json(data_root / "timeline.json")

    approvals = summary.get("approvals", [])
    total_steps = summary.get("totalSteps", 1) or 1
    completed_steps = summary.get("completedSteps", 0)
    base_alpha_probability = summary.get("estimatedAlphaProbability", 0.0)

    antifragility_index = min(
        1.0,
        command.antifragility_buffer_percent / 80.0 + simulations.get("resilience_bonus", 0.18),
    )
    owner_empowerment = min(
        1.0,
        0.35
        + 0.05 * len(command.session_keys)
        + 0.08 * len(command.guardian_failover)
        + 0.07 * len(approvals)
        + (0.05 if command.delegation_matrix.get("treasury") else 0.0)
        + (0.05 if command.delegation_matrix.get("governance") else 0.0)
        + (0.04 if command.delegation_matrix.get("execution") else 0.0)
        + (0.04 if command.emergency_pause else 0.0)
        + min(0.06, command.unstoppable_reserve_percent / 600.0),
    )
    control_surface_score = min(
        1.0,
        0.4
        + 0.05 * len(command.guardians)
        + 0.04 * len(command.guardian_failover)
        + 0.05 * len(command.session_keys)
        + min(0.05, command.unstoppable_reserve_percent / 500.0)
        + (0.04 if command.delegation_matrix.get("emergency_override") else 0.0)
        + (0.04 if command.treasury_policy.get("risk_limits", {}).get("circuit_breaker_percent") else 0.0)
        + (0.03 if simulations.get("world_model", {}).get("adaptive") else 0.0)
    )
    alpha_compounding_index = min(
        1.0,
        base_alpha_probability
        * (1.0 + execution_routes.get("compounding_multiplier", 0.22))
        + simulations.get("alpha_feedback", 0.05),
    )

    owner_levers = sorted(
        set(
            governance_matrix.get("owner_actions", [])
            + execution_routes.get("owner_switches", [])
            + [
                f"Guardian quorum {command.approvals_required}/{command.guardian_count}",
                f"Circuit breaker {command.circuit_breaker_window_minutes} minutes",
                f"Unstoppable reserve {command.unstoppable_reserve_percent:.1f}%",
                f"Antifragility buffer {command.antifragility_buffer_percent:.1f}%",
                f"Bundler {command.bundler}",
                f"Paymaster {command.paymaster}",
            ]
        )
    )

    mermaid_flow = dedent(
        f"""
        graph TD
          Owner((Sovereign Owner)) --> Identify[Identify Mesh]
          Identify --> Learn[Open-Ended Curriculum]
          Learn --> Think[Meta-Agentic Planner]
          Think --> Design[Creative Forge]
          Design --> Strategise[Treasury Dominion]
          Strategise --> Execute[On-Chain Execution Fabric]
          Execute --> Govern[Guardian & Timelock Grid]
          Govern --> Owner
          subgraph A2A Meta-Bus
            PlannerAgent((Strategy))
            RiskAgent((Risk))
            TreasuryAgent((Treasury))
            EthicsAgent((Governance))
            GuardianAgent((Guardian Mesh))
          end
          Think --> A2A Meta-Bus
          A2A Meta-Bus --> Execute
          Execute -->|Dry-run + eth_call| Confirm{{Simulation Envelope}}
          Confirm --> Execute
        """
    ).strip()

    mermaid_sequence = dedent(
        """
        sequenceDiagram
          participant Owner as Sovereign Owner
          participant Console as Meta-Dominion Console
          participant Planner as Meta-Agentic Planner
          participant Guardians as Guardian Mesh
          participant Chain as AGI Jobs v0 (v2)
          Owner->>Console: Launch α-Dominion run
          Console->>Planner: Submit scenario YAML
          Planner->>Guardians: Request approvals & antifragility check
          Guardians->>Chain: Simulate job + stake + treasury moves
          Chain-->>Console: Return receipts & run telemetry
          Console-->>Owner: Render dominance dashboard + command levers
        """
    ).strip()

    mermaid_gantt = dedent(
        """
        gantt
          title Meta-Agentic α-Dominion Timeline
          dateFormat X
          axisFormat %s
          section Identify
            Signal fusion           :done,    0, 1
            Opportunity triage      :active,  1, 1
          section Learn
            Curriculum evolution    :        2, 2
            World model alignment   :        4, 2
          section Strategise
            Treasury lattice        :        6, 1
            Governance verification :        7, 1
          section Execute
            Dry-run simulation      :        8, 1
            On-chain staging        :        9, 1
        """
    ).strip()

    return {
        "generated_at": datetime.now(timezone.utc).isoformat(),
        "alpha": alpha,
        "opportunity_graph": opportunity_graph,
        "governance": governance_matrix,
        "guardian_mesh": guardian_mesh,
        "execution_routes": execution_routes,
        "simulations": simulations,
        "timeline": timeline,
        "metrics": {
            "alpha_probability": base_alpha_probability,
            "alpha_compounding_index": alpha_compounding_index,
            "owner_empowerment": owner_empowerment,
            "antifragility_index": antifragility_index,
            "control_surface_score": control_surface_score,
            "step_completion_ratio": completed_steps / total_steps,
            "scoreboard": scoreboard,
        },
        "control_surface": {
            "score": control_surface_score,
            "guardian_quorum": command.approvals_required,
            "guardian_count": command.guardian_count,
            "failover_guardian_count": len(command.guardian_failover),
            "emergency_pause": command.emergency_pause,
            "circuit_breaker_minutes": command.circuit_breaker_window_minutes,
            "unstoppable_reserve_percent": command.unstoppable_reserve_percent,
            "antifragility_buffer_percent": command.antifragility_buffer_percent,
            "session_keys": command.session_keys,
            "bundler": command.bundler,
            "paymaster": command.paymaster,
            "delegation": command.delegation_matrix,
            "levers": owner_levers,
        },
        "mermaid": {
            "flow": mermaid_flow,
            "sequence": mermaid_sequence,
            "gantt": mermaid_gantt,
        },
        "approvals": approvals,
    }


def generate_meta_report(package_root: Path, summary: Dict[str, Any], dashboard: Dict[str, Any]) -> Path:
    """Render the V6 masterplan markdown deck."""

    reports_dir = package_root / "reports" / "generated"
    reports_dir.mkdir(parents=True, exist_ok=True)
    path = reports_dir / "alpha_dominion_masterplan.md"

    alpha_domains = dashboard["alpha"].get("domains", [])
    guardians = dashboard["guardian_mesh"].get("sentinels", [])
    controls = dashboard["governance"].get("controls", {})
    timeline = dashboard["timeline"].get("events", [])
    control_surface = dashboard["control_surface"]

    def _format_domains() -> str:
        rows = []
        for domain in alpha_domains:
            rows.append(
                "| {title} | {signal:.1f}% | ${alpha:,} | {horizon} |".format(
                    title=domain.get("title"),
                    signal=domain.get("signal_strength", 0.0) * 100,
                    alpha=int(domain.get("alpha_projection", 0)),
                    horizon=domain.get("execution_horizon", "T+0"),
                )
            )
        return "\n".join(rows)

    report = dedent(
        f"""
        # Meta-Agentic α-Dominion Masterplan (V6)

        **Generated:** {dashboard['generated_at']} UTC
        **Scenario:** {summary.get('scenarioId')}

        ## Opportunity Synthesis

        | Domain | Signal Strength | Alpha Projection | Execution Horizon |
        | --- | --- | --- | --- |
        {_format_domains()}

        ## Guardian Mesh

        | Sentinel | Capabilities | Stake | Status |
        | --- | --- | --- | --- |
        {os.linesep.join(f"| {agent['id']} | {', '.join(agent['capabilities'])} | {agent['stake']:,} AGIALPHA | {agent['status']} |" for agent in guardians)}

        ## Owner Command Surface

        - Guardian quorum: {control_surface['guardian_quorum']} approvals / {control_surface['guardian_count']} primaries
        - Failover guardians: {control_surface['failover_guardian_count']}
        - Circuit breaker: {control_surface['circuit_breaker_minutes']} minutes
        - Unstoppable reserve: {control_surface['unstoppable_reserve_percent']:.1f}%
        - Antifragility buffer: {control_surface['antifragility_buffer_percent']:.1f}%
        - Session keys: {', '.join(control_surface['session_keys'])}
        - Bundler: {control_surface['bundler']}
        - Paymaster: {control_surface['paymaster']}
        - Delegation matrix: {json.dumps(control_surface['delegation'], indent=2)}

        ## Strategic Controls

        | Control | Status |
        | --- | --- |
        {os.linesep.join(f"| {key} | {value} |" for key, value in controls.items())}

        ## Execution Timeline

        {os.linesep.join(f"- **{event['time']}** — {event['event']}" for event in timeline)}

        ## Metrics

        - Alpha probability: {dashboard['metrics']['alpha_probability']*100:.2f}%
        - Alpha compounding index: {dashboard['metrics']['alpha_compounding_index']*100:.2f}%
        - Owner empowerment: {dashboard['metrics']['owner_empowerment']*100:.2f}%
        - Antifragility index: {dashboard['metrics']['antifragility_index']*100:.2f}%
        - Control surface score: {dashboard['metrics']['control_surface_score']*100:.2f}%
        - Steps completed: {summary.get('completedSteps')}/{summary.get('totalSteps')}

        ## Meta-Agentic Flow

        ```mermaid
        {dashboard['mermaid']['flow']}
        ```

        ## Guardian Coordination Sequence

        ```mermaid
        {dashboard['mermaid']['sequence']}
        ```

        ## Execution Timeline Gantt

        ```mermaid
        {dashboard['mermaid']['gantt']}
        ```

        ## Scoreboard Snapshot

        ```json
        {json.dumps(dashboard['metrics']['scoreboard'], indent=2)}
        ```
        """
    ).strip() + "\n"

    path.write_text(report, encoding="utf-8")
    return path


def run_meta_dominion_demo(
    config_path: Path | None = None,
    *,
    timeout: float = 150.0,
) -> AlphaDominionOutcome:
    """Execute the Meta-Agentic α-AGI Jobs V6 demo end-to-end."""

    if config_path is None:
        config_path = DEFAULT_CONFIG_PATH
    config = load_configuration(config_path)
    command_matrix = validate_owner_command(config)

    package_root = config.base_dir
    demo_root = package_root.parent

    env_map = prepare_environment(demo_root)
    outcome = run_demo(config, timeout=timeout)

    summary = json.loads(outcome.summary_path.read_text(encoding="utf-8"))
    summary["approvals"] = config.approvals
    summary["scenarioId"] = config.payload.get("scenario", {}).get("id")
    summary["agents"] = outcome.metadata.get("onboarded_agents", [])

    scoreboard_path = Path(env_map["ORCHESTRATOR_SCOREBOARD_PATH"])
    scoreboard = outcome.scoreboard_snapshot or {}

    dashboard_payload = generate_dashboard_payload(package_root, summary, scoreboard, command_matrix)
    dashboard_path = package_root / "ui" / "dashboard-data-v6.json"
    dashboard_path.write_text(json.dumps(dashboard_payload, ensure_ascii=False, indent=2), encoding="utf-8")

    report_path = generate_meta_report(package_root, summary, dashboard_payload)

    latest_run_path = demo_root / "storage" / "latest_run_v6.json"
    latest_run_path.write_text(json.dumps(summary, ensure_ascii=False, indent=2), encoding="utf-8")

    return AlphaDominionOutcome(
        base=outcome,
        summary_path=latest_run_path,
        dashboard_path=dashboard_path,
        report_path=report_path,
        scoreboard_path=scoreboard_path,
        dashboard_payload=dashboard_payload,
        command_matrix=command_matrix,
    )


__all__ = [
    "DEFAULT_CONFIG_PATH",
    "OwnerCommandMatrix",
    "AlphaDominionOutcome",
    "prepare_environment",
    "validate_owner_command",
    "generate_dashboard_payload",
    "generate_meta_report",
    "run_meta_dominion_demo",
]
