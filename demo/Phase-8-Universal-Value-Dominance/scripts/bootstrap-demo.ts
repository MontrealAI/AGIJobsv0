#!/usr/bin/env ts-node
import { promises as fs } from "fs";
import path from "path";
import { fileURLToPath } from "url";
import { ethers } from "ethers";
import prompts from "prompts";

interface GovernancePolicies {
  owner: string;
  governanceCouncil: string[];
  pauseGuardian: string;
  validatorGuild: string;
  globalPause: boolean;
  budgetCapUSD: number;
  ci: {
    workflow: string;
    requireStatusChecks: string[];
  };
  upgradeHooks: Record<string, string>;
}

interface ModelAdapterConfig {
  id: string;
  provider: string;
  maxContext: number;
  costUSDPer1KTokens: number;
  safetyScore: number;
  latencyMs: number;
  lastValidated: string;
}

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const CONFIG_DIR = path.resolve(__dirname, "../configs");

async function readJSON<T>(file: string): Promise<T> {
  const buffer = await fs.readFile(path.join(CONFIG_DIR, file), "utf8");
  return JSON.parse(buffer) as T;
}

async function ensureEnv(key: string): Promise<string> {
  const value = process.env[key];
  if (!value) {
    throw new Error(`Missing required environment variable ${key}`);
  }
  return value;
}

async function connectProvider() {
  const rpcUrl = await ensureEnv("RPC_URL");
  const privateKey = await ensureEnv("OWNER_PRIVATE_KEY");
  const provider = new ethers.JsonRpcProvider(rpcUrl);
  const wallet = new ethers.Wallet(privateKey, provider);
  return { provider, wallet };
}

async function confirmIntent(policies: GovernancePolicies) {
  console.log("\n=== Phase 8 Bootstrap ===\n");
  console.table({
    Owner: policies.owner,
    PauseGuardian: policies.pauseGuardian,
    ValidatorGuild: policies.validatorGuild,
    BudgetCapUSD: policies.budgetCapUSD
  });

  const response = await prompts({
    type: "confirm",
    name: "ready",
    message: "Proceed with governance + infrastructure bootstrap?",
    initial: true
  });

  if (!response.ready) {
    console.log("Aborted by operator.");
    process.exit(0);
  }
}

async function pushGovernanceUpdates(wallet: ethers.Wallet, policies: GovernancePolicies) {
  console.log("\n[1/3] Updating governance policies...");
  // Placeholder for actual contract interactions.
  // In production this would use typed contract factories generated by TypeChain.
  console.log(` - Setting pause guardian (${policies.pauseGuardian}) via owner proxy ${policies.owner}`);
  console.log(` - Syncing validator guild multisig ${policies.validatorGuild}`);
  console.log(` - Enforcing CI workflow ${policies.ci.workflow}`);
  console.log(` - Registering upgrade hooks: ${Object.values(policies.upgradeHooks).join(", ")}`);
  await wallet.getNonce(); // Dummy chain interaction to ensure connection works.
}

async function registerModelAdapters(wallet: ethers.Wallet, adapters: ModelAdapterConfig[]) {
  console.log("\n[2/3] Registering model adapters...");
  adapters
    .sort((a, b) => b.safetyScore - a.safetyScore)
    .forEach((adapter, index) => {
      console.log(
        ` ${index + 1}. ${adapter.id} (provider=${adapter.provider}, context=${adapter.maxContext}, safety=${adapter.safetyScore})`
      );
    });
  console.log(" - Pushing adapters to ModelRegistry...");
  await wallet.getBalance(); // Connection health check.
}

async function seedValidatorGuild(wallet: ethers.Wallet, policies: GovernancePolicies) {
  console.log("\n[3/3] Seeding validator guild registry...");
  policies.governanceCouncil.forEach((member) => {
    console.log(` - Adding council member ${member}`);
  });
  console.log(` - Linking guild ${policies.validatorGuild} with attestation service.`);
  await wallet.getAddress();
}

async function main() {
  const policies = await readJSON<GovernancePolicies>("governance-policies.json");
  const adapters = await readJSON<ModelAdapterConfig[]>("model-adapters.json");

  await confirmIntent(policies);
  const { wallet } = await connectProvider();

  await pushGovernanceUpdates(wallet, policies);
  await registerModelAdapters(wallet, adapters);
  await seedValidatorGuild(wallet, policies);

  console.log("\nBootstrap complete. Proceed to launch the mission via UI or CLI.");
}

main().catch((error) => {
  console.error("Bootstrap failed:", error);
  process.exit(1);
});
