import fs from 'fs';
import path from 'path';
import { ethers, Wallet } from 'ethers';
import { Job } from './types';
import { AgentProfile, JobAnalysis } from './agentRegistry';
import { AgentIdentity } from './identity';
import { registry, FETCH_TIMEOUT_MS, TOKEN_DECIMALS } from './utils';
import {
  startEnergySpan,
  endEnergySpan,
  EnergySample,
} from '../shared/energyMonitor';
import { recordAuditEvent } from '../shared/auditLogger';
import { publishEnergySample } from './telemetry';
import { notifyTrainingOutcome } from './learning';

export interface TaskExecutionContext {
  job: Job;
  wallet: Wallet;
  profile: AgentProfile;
  identity: AgentIdentity;
  analysis: JobAnalysis;
}

export interface TaskExecutionResult {
  txHash: string;
  resultURI: string;
  resultHash: string;
  payloadDigest: string;
  resultSignature: string;
  outputPath: string;
  energy: EnergySample;
  rawOutput: unknown;
}

const RESULT_DIR = path.resolve(__dirname, '../storage/results');

function ensureDir(dir: string): void {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
}

function resolveRewardValue(job: Job): number {
  if (job?.reward) {
    const parsed = Number.parseFloat(job.reward);
    if (Number.isFinite(parsed)) {
      return parsed;
    }
  }
  if (job?.rewardRaw) {
    try {
      const value = ethers.formatUnits(
        BigInt(job.rewardRaw),
        Number(TOKEN_DECIMALS)
      );
      const parsed = Number.parseFloat(value);
      if (Number.isFinite(parsed)) {
        return parsed;
      }
    } catch (err) {
      console.warn('Failed to normalise reward value for job', job.jobId, err);
    }
  }
  return 0;
}

async function acknowledgeTaxPolicy(wallet: Wallet): Promise<void> {
  try {
    const policy = await (registry as any).taxPolicy();
    if (policy && policy !== ethers.ZeroAddress) {
      await (registry as any).connect(wallet).acknowledgeTaxPolicy();
    }
  } catch (err: any) {
    if (err?.message && err.message.includes('AlreadyAcknowledged')) {
      return;
    }
    // ignore benign failures such as already acknowledged
  }
}

async function invokeAgentEndpoint(
  endpoint: string,
  payload: unknown,
  timeoutMs: number
): Promise<unknown> {
  const controller = new AbortController();
  const timer = setTimeout(() => controller.abort(), timeoutMs);
  try {
    const res = await fetch(endpoint, {
      method: 'POST',
      headers: { 'content-type': 'application/json' },
      body: JSON.stringify(payload),
      signal: controller.signal,
    });
    if (!res.ok) {
      throw new Error(`HTTP ${res.status} ${res.statusText}`);
    }
    const text = await res.text();
    try {
      return JSON.parse(text);
    } catch {
      return text;
    }
  } finally {
    clearTimeout(timer);
  }
}

function fallbackSolveJob(context: TaskExecutionContext): unknown {
  const { job, analysis } = context;
  return {
    jobId: job.jobId,
    summary: 'Autogenerated fallback solution',
    analysis,
    timestamp: new Date().toISOString(),
  };
}

function serialiseResult(result: unknown): string {
  if (typeof result === 'string') return result;
  return JSON.stringify(result, null, 2);
}

async function persistResult(jobId: string, payload: string): Promise<string> {
  ensureDir(RESULT_DIR);
  const file = path.join(RESULT_DIR, `${jobId}.json`);
  await fs.promises.writeFile(file, payload, 'utf8');
  return file;
}

export async function executeJob(
  context: TaskExecutionContext
): Promise<TaskExecutionResult> {
  const { job, wallet, profile, identity, analysis } = context;
  const rewardValue = resolveRewardValue(job);
  const span = startEnergySpan({
    jobId: job.jobId,
    agent: wallet.address,
    label: identity.label,
    category: analysis.category,
  });
  let resultURI = '';
  let resultHash = '';
  let payloadDigest = '';
  let resultSignature = '';
  let txHash = '';
  let rawOutput: unknown;
  let outputPath = '';
  let error: Error | null = null;
  let energySample: EnergySample | null = null;

  try {
    const payload = {
      job,
      analysis,
      profile: {
        address: profile.address,
        categories: profile.categories,
        skills: profile.skills,
      },
      identity,
    };
    if (profile.endpoint) {
      try {
        rawOutput = await invokeAgentEndpoint(
          profile.endpoint,
          payload,
          FETCH_TIMEOUT_MS
        );
      } catch (err) {
        console.warn('Agent endpoint invocation failed, falling back', err);
        rawOutput = fallbackSolveJob(context);
      }
    } else {
      rawOutput = fallbackSolveJob(context);
    }
    const serialised = serialiseResult(rawOutput);
    outputPath = await persistResult(job.jobId, serialised);
    const hashBytes = ethers.id(serialised);
    resultHash = hashBytes;
    resultURI = `ipfs://local/${hashBytes}`;
    payloadDigest = ethers.keccak256(ethers.toUtf8Bytes(serialised));
    resultSignature = await wallet.signMessage(ethers.getBytes(payloadDigest));
    await acknowledgeTaxPolicy(wallet);
    const tx = await (registry as any)
      .connect(wallet)
      .submit(job.jobId, hashBytes, resultURI, identity.label ?? '', []);
    await tx.wait();
    txHash = tx.hash;
    await recordAuditEvent(
      {
        component: 'task-execution',
        action: 'submit',
        jobId: job.jobId,
        agent: wallet.address,
        metadata: {
          resultURI,
          resultHash,
          txHash,
          payloadDigest,
          resultSignature,
        },
        success: true,
      },
      wallet
    );
  } catch (err: any) {
    error = err instanceof Error ? err : new Error(err?.message || String(err));
    await recordAuditEvent(
      {
        component: 'task-execution',
        action: 'submit-failed',
        jobId: job.jobId,
        agent: wallet.address,
        metadata: {
          error: error.message,
          resultURI,
          resultHash,
          payloadDigest,
        },
        success: false,
      },
      wallet
    );
    throw error;
  } finally {
    energySample = await endEnergySpan(span, {
      jobId: job.jobId,
      agent: wallet.address,
      success: !error,
      resultURI,
      rewardValue,
      rewardRaw: job.rewardRaw,
      rewardFormatted: job.reward,
      tokenDecimals: TOKEN_DECIMALS,
      stakeRaw: job.stakeRaw,
      stakeFormatted: job.stake,
    });
    await publishEnergySample(energySample);
    await notifyTrainingOutcome({
      job,
      profile,
      analysis,
      success: !error,
      energy: energySample,
      txHash,
      resultURI,
      resultHash,
    });
  }

  if (!energySample) {
    throw new Error('Energy sample missing after task execution');
  }
  return {
    txHash,
    resultURI,
    resultHash,
    payloadDigest,
    resultSignature,
    outputPath,
    energy: energySample,
    rawOutput,
  };
}
