import fs from 'node:fs';
import path from 'node:path';
import { ethers } from 'ethers';

import { loadTokenConfig } from './config';

type PositiveIntOptions = {
  minimum?: number;
  maximum?: number;
};

function parsePositiveInt(
  raw: string | undefined,
  label: string,
  fallback: number,
  { minimum = 1, maximum }: PositiveIntOptions = {}
): number {
  const source = raw?.trim();
  const input = source === undefined || source === '' ? `${fallback}` : source;
  if (!/^[-+]?\d+$/.test(input)) {
    throw new Error(`${label} must be an integer value`);
  }
  const value = Number.parseInt(input, 10);
  if (!Number.isFinite(value)) {
    throw new Error(`${label} is not a finite integer`);
  }
  if (value < minimum) {
    throw new Error(`${label} must be at least ${minimum}`);
  }
  if (maximum !== undefined && value > maximum) {
    throw new Error(`${label} must be <= ${maximum}`);
  }
  return value;
}

function parsePercentPoints(
  raw: string | undefined,
  label: string,
  fallback: number
): number {
  const value = parsePositiveInt(raw, label, fallback, { minimum: 1, maximum: 100 });
  return value;
}

function assertAddress(
  value: string | undefined,
  label: string,
  { allowZero = false }: { allowZero?: boolean } = {}
): string {
  if (!value || typeof value !== 'string') {
    throw new Error(`${label} is required`);
  }
  if (!ethers.isAddress(value)) {
    throw new Error(`${label} must be a valid Ethereum address`);
  }
  const normalised = ethers.getAddress(value);
  if (!allowZero && normalised === ethers.ZeroAddress) {
    throw new Error(`${label} cannot be the zero address`);
  }
  return normalised;
}

function assertDecimals(value: number): number {
  if (!Number.isInteger(value)) {
    throw new Error('decimals must be an integer');
  }
  if (value < 0 || value > 255) {
    throw new Error('decimals must be between 0 and 255');
  }
  return value;
}

function assertSymbol(value: string, label: string): string {
  if (!value || typeof value !== 'string') {
    throw new Error(`${label} is required`);
  }
  const trimmed = value.trim();
  if (!trimmed) {
    throw new Error(`${label} cannot be empty`);
  }
  if (trimmed.length > 32) {
    throw new Error(`${label} must be 32 characters or fewer`);
  }
  return trimmed;
}

function assertName(value: string, label: string): string {
  if (!value || typeof value !== 'string') {
    throw new Error(`${label} is required`);
  }
  const trimmed = value.trim();
  if (!trimmed) {
    throw new Error(`${label} cannot be empty`);
  }
  if (trimmed.length > 64) {
    throw new Error(`${label} must be 64 characters or fewer`);
  }
  return trimmed;
}

let networkArg: string | undefined;
for (let i = 0; i < process.argv.length; i++) {
  const arg = process.argv[i];
  if (arg === '--network' && i + 1 < process.argv.length) {
    networkArg = process.argv[i + 1];
    break;
  }
  if (arg.startsWith('--network=')) {
    networkArg = arg.slice('--network='.length);
    break;
  }
}

function formatDecimalFromPercent(points: number): string {
  return (points / 100).toFixed(2);
}

export async function main() {
  const {
    config: { address, decimals, symbol, name, burnAddress },
  } = loadTokenConfig({ network: networkArg });

  const agiAlphaAddress = assertAddress(address, 'AGIALPHA address');
  const decimalsValue = assertDecimals(decimals);
  const burnAddressValue = assertAddress(
    burnAddress ?? ethers.ZeroAddress,
    'burn address',
    { allowZero: true }
  );
  const tokenSymbol = assertSymbol(symbol, 'AGIALPHA symbol');
  const tokenName = assertName(name, 'AGIALPHA name');

  const feePctPoints = parsePercentPoints(process.env.FEE_PCT, 'FEE_PCT', 2);
  const burnPctPoints = parsePercentPoints(process.env.BURN_PCT, 'BURN_PCT', 6);
  const validatorsPerJob = parsePositiveInt(
    process.env.VALIDATORS_PER_JOB,
    'VALIDATORS_PER_JOB',
    3,
    { minimum: 1 }
  );
  const requiredApprovals = parsePositiveInt(
    process.env.REQUIRED_APPROVALS,
    'REQUIRED_APPROVALS',
    validatorsPerJob,
    { minimum: 1 }
  );
  if (requiredApprovals > validatorsPerJob) {
    throw new Error('REQUIRED_APPROVALS cannot exceed VALIDATORS_PER_JOB');
  }

  const commitWindowSeconds = parsePositiveInt(
    process.env.COMMIT_WINDOW_S,
    'COMMIT_WINDOW_S',
    1800,
    { minimum: 1 }
  );
  const revealWindowSeconds = parsePositiveInt(
    process.env.REVEAL_WINDOW_S,
    'REVEAL_WINDOW_S',
    1800,
    { minimum: 1 }
  );

  const treasury = assertAddress(
    process.env.TREASURY ?? '0x1111111111111111111111111111111111111111',
    'TREASURY'
  );

  const scale = BigInt(10) ** BigInt(decimalsValue);

  const constantsSol = `// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

// Shared AGI Jobs v2 constants.
// @dev Auto-generated by scripts/generate-constants.ts
// Canonical $AGIALPHA token on Ethereum mainnet.
address constant AGIALPHA = ${agiAlphaAddress};

// Standard decimals for $AGIALPHA.
uint8 constant AGIALPHA_DECIMALS = ${decimalsValue};

// ERC-20 metadata for $AGIALPHA.
string constant AGIALPHA_SYMBOL = ${JSON.stringify(tokenSymbol)};
string constant AGIALPHA_NAME = ${JSON.stringify(tokenName)};

// Base unit scaling factor for $AGIALPHA (10 ** decimals).
uint256 constant TOKEN_SCALE = ${scale};

// Address used for burning tokens.
address constant BURN_ADDRESS = ${burnAddressValue};

// Default economic configuration (percentages expressed as whole points).
uint256 constant FEE_PCT = ${feePctPoints};
uint256 constant BURN_PCT = ${burnPctPoints};
uint256 constant VALIDATORS_PER_JOB = ${validatorsPerJob};
uint256 constant REQUIRED_APPROVALS = ${requiredApprovals};
uint256 constant COMMIT_WINDOW_S = ${commitWindowSeconds};
uint256 constant REVEAL_WINDOW_S = ${revealWindowSeconds};
address constant TREASURY = ${treasury};
`;

  const constantsPath = path.join(__dirname, '..', 'contracts', 'v2', 'Constants.sol');
  fs.writeFileSync(constantsPath, constantsSol);
  console.log(`Generated ${constantsPath}`);

  const feePctDecimal = formatDecimalFromPercent(feePctPoints);
  const burnPctDecimal = formatDecimalFromPercent(burnPctPoints);
  const commitWindowLabel = `${commitWindowSeconds}s`;
  const revealWindowLabel = `${revealWindowSeconds}s`;

  const protocolDefaults = {
    feePct: feePctDecimal,
    feePctPercent: feePctPoints,
    feePctBasisPoints: feePctPoints * 100,
    feePctPoints,
    burnPct: burnPctDecimal,
    burnPctPercent: burnPctPoints,
    burnPctBasisPoints: burnPctPoints * 100,
    burnPctPoints,
    treasury,
    validatorsPerJob,
    requiredApprovals,
    commitWindow: commitWindowLabel,
    commitWindowSeconds,
    commitWindowS: commitWindowSeconds,
    revealWindow: revealWindowLabel,
    revealWindowSeconds,
    revealWindowS: revealWindowSeconds,
  } as const;

  const generatedDir = path.join(__dirname, 'generated');
  fs.mkdirSync(generatedDir, { recursive: true });

  const protocolDefaultsTs = `// Auto-generated by scripts/generate-constants.ts\n// Do not edit manually.\n\nexport interface ProtocolDefaults {\n  feePct: string;\n  feePctPercent: number;\n  feePctBasisPoints: number;\n  feePctPoints: number;\n  burnPct: string;\n  burnPctPercent: number;\n  burnPctBasisPoints: number;\n  burnPctPoints: number;\n  treasury: string;\n  validatorsPerJob: number;\n  requiredApprovals: number;\n  commitWindow: string;\n  commitWindowSeconds: number;\n  commitWindowS: number;\n  revealWindow: string;\n  revealWindowSeconds: number;\n  revealWindowS: number;\n}\n\nexport const PROTOCOL_DEFAULTS: ProtocolDefaults = ${JSON.stringify(
    protocolDefaults,
    null,
    2
  )} as const;\n`;

  const generatedTsPath = path.join(generatedDir, 'protocol-defaults.ts');
  fs.writeFileSync(generatedTsPath, protocolDefaultsTs);
  console.log(`Generated ${generatedTsPath}`);

  const generatedJsonDir = path.join(
    __dirname,
    '..',
    'deployment-config',
    'generated'
  );
  fs.mkdirSync(generatedJsonDir, { recursive: true });
  const protocolDefaultsJsonPath = path.join(
    generatedJsonDir,
    'protocol-defaults.json'
  );
  fs.writeFileSync(
    protocolDefaultsJsonPath,
    `${JSON.stringify(protocolDefaults, null, 2)}\n`
  );
  console.log(`Generated ${protocolDefaultsJsonPath}`);
}
