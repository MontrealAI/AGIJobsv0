import * as fs from 'fs';
import * as path from 'path';
import { ethers } from 'ethers';
import { loadTokenConfig, ms } from './config';

const BPS = 10_000;

const toBps = (value: number): number => {
  if (!Number.isFinite(value)) return 0;
  const scaled = Math.round(value * BPS);
  if (scaled <= 0) return 0;
  if (scaled >= BPS) return BPS;
  return scaled;
};

const toUint8 = (value: number, fallback: number): number => {
  if (!Number.isFinite(value)) return fallback;
  const normalised = Math.floor(value);
  if (normalised < 0) return fallback;
  if (normalised > 255) return 255;
  return normalised;
};

const DEAD_ADDRESS = '0x000000000000000000000000000000000000dEaD';

const resolveAddress = (value: string | undefined | null): string => {
  if (!value) {
    return DEAD_ADDRESS;
  }
  try {
    const address = ethers.getAddress(value);
    return address === ethers.ZeroAddress ? DEAD_ADDRESS : address;
  } catch (err) {
    return DEAD_ADDRESS;
  }
};

function assertAddress(
  value: string,
  label: string,
  { allowZero = false }: { allowZero?: boolean } = {}
): string {
  if (!value || typeof value !== 'string') {
    throw new Error(`${label} is required`);
  }
  if (!ethers.isAddress(value)) {
    throw new Error(`${label} must be a valid Ethereum address`);
  }
  const normalised = ethers.getAddress(value);
  if (!allowZero && normalised === ethers.ZeroAddress) {
    throw new Error(`${label} cannot be the zero address`);
  }
  return normalised;
}

function assertDecimals(value: number): number {
  if (!Number.isInteger(value)) {
    throw new Error('decimals must be an integer');
  }
  if (value < 0 || value > 255) {
    throw new Error('decimals must be between 0 and 255');
  }
  return value;
}

function assertSymbol(value: string, label: string): string {
  if (!value || typeof value !== 'string') {
    throw new Error(`${label} is required`);
  }
  const trimmed = value.trim();
  if (!trimmed) {
    throw new Error(`${label} cannot be empty`);
  }
  if (trimmed.length > 32) {
    throw new Error(`${label} must be 32 characters or fewer`);
  }
  return trimmed;
}

function assertName(value: string, label: string): string {
  if (!value || typeof value !== 'string') {
    throw new Error(`${label} is required`);
  }
  const trimmed = value.trim();
  if (!trimmed) {
    throw new Error(`${label} cannot be empty`);
  }
  if (trimmed.length > 64) {
    throw new Error(`${label} must be 64 characters or fewer`);
  }
  return trimmed;
}

let networkArg: string | undefined;
for (let i = 0; i < process.argv.length; i++) {
  const arg = process.argv[i];
  if (arg === '--network' && i + 1 < process.argv.length) {
    networkArg = process.argv[i + 1];
    break;
  }
  if (arg.startsWith('--network=')) {
    networkArg = arg.slice('--network='.length);
    break;
  }
}

const { config } = loadTokenConfig({ network: networkArg });

const feePctBps = toBps(Number(process.env.FEE_PCT ?? 0.02));
const burnPctBps = toBps(Number(process.env.BURN_PCT ?? 0.06));

const validatorsPerJobRaw = toUint8(
  Number(process.env.VALIDATORS_PER_JOB ?? 3),
  3
);
const validatorsPerJob = validatorsPerJobRaw === 0 ? 1 : validatorsPerJobRaw;

let requiredApprovals = toUint8(
  Number(process.env.REQUIRED_APPROVALS ?? validatorsPerJob),
  validatorsPerJob
);
if (requiredApprovals === 0) {
  requiredApprovals = validatorsPerJob;
}
if (requiredApprovals > validatorsPerJob) {
  requiredApprovals = validatorsPerJob;
}

const commitWindowMs = ms(
  process.env.COMMIT_WINDOW ?? '30m',
  30 * 60 * 1000
);
const revealWindowMs = ms(
  process.env.REVEAL_WINDOW ?? '30m',
  30 * 60 * 1000
);

const treasury = resolveAddress(process.env.TREASURY);

const address = assertAddress(config.address, 'AGIALPHA address');
const decimals = assertDecimals(config.decimals);
const burnAddress = assertAddress(
  config.burnAddress ?? ethers.ZeroAddress,
  'burn address',
  {
    allowZero: true,
  }
);
const symbol = assertSymbol(config.symbol, 'AGIALPHA symbol');
const name = assertName(config.name, 'AGIALPHA name');

// Compute the token scale (10 ** decimals) using BigInt to avoid precision loss.
const scale = BigInt(10) ** BigInt(decimals);

const content = `// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

library ConstantsV2 {
  uint16 constant FEE_PCT_BPS = ${feePctBps};
  uint16 constant BURN_PCT_BPS = ${burnPctBps};
  uint8 constant VALIDATORS_PER_JOB = ${validatorsPerJob};
  uint8 constant REQUIRED_APPROVALS = ${requiredApprovals};
  uint256 constant COMMIT_WINDOW_MS = ${commitWindowMs};
  uint256 constant REVEAL_WINDOW_MS = ${revealWindowMs};
  address constant TREASURY = ${treasury};
}

// Shared AGI Jobs v2 constants.
// @dev Auto-generated by scripts/generate-constants.ts
// Canonical $AGIALPHA token on Ethereum mainnet.
address constant AGIALPHA = ${address};

// Standard decimals for $AGIALPHA.
uint8 constant AGIALPHA_DECIMALS = ${decimals};

// ERC-20 metadata for $AGIALPHA.
string constant AGIALPHA_SYMBOL = ${JSON.stringify(symbol)};
string constant AGIALPHA_NAME = ${JSON.stringify(name)};

// Base unit scaling factor for $AGIALPHA (10 ** decimals).
uint256 constant TOKEN_SCALE = ${scale};

// Address used for burning tokens.
address constant BURN_ADDRESS = ${burnAddress};
`;

const outPath = path.join(__dirname, '..', 'contracts', 'v2', 'Constants.sol');
fs.writeFileSync(outPath, content);
console.log(`Generated ${outPath}`);
