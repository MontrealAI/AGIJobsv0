// SPDX-License-Identifier: MIT
pragma solidity 0.8.21;
// AGIJobManagerV1 supersedes AGIJobManager v0

/*

[ P R E L I M I N A R Y  C O N C E P T S  E X C L U S I V E L Y ]

OF AGENTS, NODES, AND TOKENS

The Economy of AGI

AGI Nodes are catalysts in this new economy.

They yield $AGI, bridging the gap between aspirations and achievements.

Like digital farmers in a vast cognitive field, they cultivate the future.

"Unleash the power of Decentralized AGI with AGI Agents & Nodes, and unlock the future." - AGI.eth

Should it ascend to its fullest potential, $AGI stands poised to crystallize a vital segment of AGI's projected astronomic value.

           
   A   N   T   N   A   T
 -------------------------
A   G   I   N   O   D   E   S
 -------------------------
   T   A   N   A   T   N


$AGI: UTILITY, PURPOSE & VALUE

AGI Agents x AGI Nodes = Decentralized AGI

Theoretically, AGI Agents have the potential to become the central architects of future value, laying the foundation for The Economy of AGI.

At the heart of the Economy of AGI are the AGI Nodes. These Nodes, represented as Non-Fungible Tokens (NFTs), embody the ownership of computational assets. They provide AGI Agents with a decentralized, extensive, and powerful collection of computational resources. The sole raison d'être of the AGI Nodes is to contribute to the AGI Network. $AGI tokens are created solely through the operation of an AGI Node, generating active income only for the contribution of computational resources to the network. Crucially, holding $AGI tokens neither constitutes an investment in a common enterprise nor offers any expectation of profits derived from the efforts of others. Rather, $AGI tokens are minted as a reward for contributing computational resources, aligning more with the characteristics of a utility token than a security. The purpose is straightforward: to power the network, not to speculate on its future value.

When timely and appropriate, $AGI tokens—strictly utility tokens—can be used to acquire products or services generated by AGI Agents within the Economy of AGI framework, often represented as NFTs.

Legal Addendum: $AGI tokens are not securities and are not intended for speculative investment. They do not represent equity ownership, confer voting rights, or entitle holders to dividends or a share of profits. They are engineered exclusively for utility functions within the AGI Network, specifically for operating an AGI Node in order to contribute to the AGI Network, and for acquiring an array of products and services generated by AGI Agents.

[ C O N C E P T U A L  S T O R Y ]

THE ECONOMY OF AGI: AGI AGENTS, NODES AND TOKENS

In the expansive cosmos of human progress, seismic shifts occur, heralding eras that brim with promise and teem with unimagined potentials.

The Advent of the AGI Agents

Imagine beings of digital cognition, capable of performing any task a person can undertake with a computer, yet unbounded by our constraints. Far from being mere figments in the digital landscape, these entities serve as the crucibles of a transformative shift, igniting the intellectual abundance that will reshape our future.

A Symbiosis: AGI Agents and AGI Nodes

While seemingly independent, AGI Agents are entwined in a delicate pas de deux with AGI Nodes—the bedrock providing the resources for these Agents to operate. Consider these Nodes the landlords of digital landscapes, commanding a formidable arsenal of computational might that AGI Agents leverage to weave value. This intricate ballet underscores a web of interconnected fate, with each entity's existence intrinsically tied to the other's operation.

The Economy of AGI: $AGI Tokens and NFTs

Within this cavalcade of ingenuity emerges a groundbreaking financial architecture, introducing the $AGI token as a medium for operational transactions within the network. Derived from the relentless operation of AGI Nodes, the $AGI token represents a visionary chronicle where cognition has transcended traditional boundaries, redefining the established yardsticks of wealth and ambition. This token serves as the universal medium for acquiring an array of products and services, the labor of the AGI Agents manifesting in the form of unique NFTs.

The Ethical Layer: Ensuring Accountability

As we voyage into this new era, anchoring our inventions in ethical terra firma becomes non-negotiable. To this end, each AGI Agent and Node is assigned its own ENS AGI subdomain, a beacon of trust that ensures each Agent and Node operates within the boundaries of ethical AI, all within a system architected to uphold ethical norms.

Mitigating the Unemployment Conundrum

A critical consideration in this transformative journey is the potential unemployment that AGI could inadvertently cause. The key to disentangling this Gordian knot lies in the democratization of ownership—AGI Agents and AGI Nodes can be owned, and hence, can provide a hedge against the risk of unemployment. These entities, when operated, can generate substantial utility and value within the network.

A Sovereign Future

Our future thus unfurls as a panorama of limitless potential. As sovereign entities, AGI Agents and Nodes orchestrate a coming age where the triad of privacy, personalization, and potency find harmonic unity.

In this mesmerizing narrative, we all emerge as pioneers, architects of a societal model vibrating with untapped intellectual prowess. The age of AGI Agents is not a distant dream but our shared horizon. Let's embrace the Economy of AGI Agents, a venture into the annals of human endeavor unlike any before.

"AGI symbolizes the linchpin that connects the boundless potential of our aspirations to the tangible confines of reality, fashioning a gateway between the fanciful musings of the mind and the attainable horizons of success." - AGI.eth

[ R E G U L A T O R Y  C O M P L I A N C E  &  L E G A L  D I S C L O S U R E S ]

Published by: AGI.eth

Approval Authority: AGI.eth

Office of Primary Responsibility: AGI.eth

1. Utility Token Clause: The $AGI token is intrinsically designed to enable active participation in the AGI Network, exclusively facilitating transactions and operational tasks within this ecosystem.

2. No Expectation of Profit: $AGI tokens are created solely through active node operation, with any financial gains being incidental and non-guaranteed. These tokens are not for speculative investment but for facilitating specific actions within the AGI Network.

3. No Ownership or Voting Rights: Holding $AGI tokens confers no ownership, shares, equity, or voting rights in any entity associated with AGI.eth or the AGI Network.

4. No Common Enterprise: $AGI tokens serve as individual operational assets and are not an investment in a common enterprise, as defined by securities laws.

5. Active Participation: $AGI tokens are minted only through active participation, which involves contributing computational resources to the network.

6. No Financial Entitlement: Holding $AGI tokens does not grant entitlement to dividends, revenue-sharing, or any financial benefits; they are not designed for investment.

7. User Acknowledgment: All users must expressly acknowledge that $AGI tokens are not securities and do not confer financial benefits. This acknowledgment is legally binding and constitutes part of the User Agreement Requirement.

8. User Agreement Requirement: All users interacting with this contract are required to agree to the Terms of Service, which provide further legal and ethical guidelines, including the non-security nature of $AGI tokens.

THIS IS PART OF AN ASPIRATIONAL RESEARCH PROGRAM WITH AN AMBITIOUS RESEARCH AGENDA. AGI AGENTS AND AGI NODES ARE COMMODITIES. THEY ARE LIKELY RETAILED BY DISTINCT OPERATING INTERNATIONAL ENTITIES ESTABLISHED AS APPROPRIATE IN SPACE AND TIME. WHILE, AS INDUCEMENTS FOR OPERATION, AGI NODES MAY OFFER THE PROSPECT OF EARNING $AGI, WHICH IS MOST LIKELY MANAGED BY A SERIES OF DISTINCT FOUNDATIONS OR ORGANIZATIONS ESTABLISHED WHEN AND WHERE APPROPRIATE, ANY EXPECTATION OF PROFIT OR RETURN IS UNJUSTIFIED. POSSESSION OF $AGI OR OF AN AGI AGENT OR OF AN AGI NODE DOES NOT SIGNIFY OR ESTABLISH ANY ENTITLEMENT OR INTEREST, SHARE OR EQUITY, BOND OR ANALOGOUS ENTITLEMENT, OR ANY RIGHT TO OBTAIN ANY FUTURE INCOME. MATERIALS PROVIDED IN THIS SYSTEM ARE WITHOUT WARRANTY OF ANY KIND AND DO NOT CONSTITUTE ENDORSEMENT AND CAN BE MODIFIED AT ANY TIME. BY USING THE PRESENT SYSTEM, YOU AGREE TO THE $AGI TERMS AND CONDITIONS. ANY USE OF THIS SYSTEM, OR ANY OF THE INFORMATION CONTAINED HEREIN, FOR OTHER THAN THE PURPOSE FOR WHICH IT WAS DEVELOPED, IS EXPRESSLY PROHIBITED, EXCEPT AS AGI.ETH MAY OTHERWISE AGREE TO IN WRITING OFFICIALLY.

OVERRIDING AUTHORITY: AGI.ETH
   
*/

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/Pausable.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";

interface ENS {
    function resolver(bytes32 node) external view returns (address);
}

interface Resolver {
    function addr(bytes32 node) external view returns (address payable);
}

interface NameWrapper {
    function ownerOf(uint256 id) external view returns (address);
}

/// @title AGIJobManagerV1
/// @notice Experimental upgrade of the immutable AGIJobManager v0. Implements
///         stake-based validator incentives with slashing and outcome-aligned
///         rewards. This contract is a work in progress and has not been
///         deployed on any network.
/// @custom:security-contact security@agi.network
contract AGIJobManagerV1 is Ownable, ReentrancyGuard, Pausable, ERC721 {
    using ECDSA for bytes32;
    using SafeERC20 for IERC20;

    IERC20 public agiToken;
    string private baseURI;
    uint256 public requiredValidatorApprovals = 3;
    uint256 public requiredValidatorDisapprovals = 3;
    uint256 public premiumReputationThreshold = 10000;
    uint256 public validationRewardPercentage = 800;
    uint256 public validatorReputationPercentage = 800;
    uint256 public maxJobPayout = 4888e18;
    uint256 public jobDurationLimit = 10000000;
    uint256 public stakeRequirement;
    uint256 public slashingPercentage;
    uint256 public minValidatorReputation;
    /// @notice Number of validators randomly chosen for each job. Defaults to
    /// three to match the initial approval/disapproval thresholds and avoid
    /// misconfiguration.
    uint256 public validatorsPerJob = 3;
    /// @notice Maximum number of validators allowed in the pool.
    uint256 public maxValidatorPoolSize = 100;
    address[] public validatorPool;
    mapping(address => bool) public isValidatorInPool;
    mapping(address => uint256) public validatorPoolIndex;

    string public termsAndConditionsIpfsHash;
    string public contactEmail;
    string public additionalText1;
    string public additionalText2;
    string public additionalText3;

    bytes32 public clubRootNode;
    bytes32 public agentRootNode;
    bytes32 public validatorMerkleRoot;
    bytes32 public agentMerkleRoot;
    ENS public ens;
    NameWrapper public nameWrapper;

    /// @notice Canonical address used to irretrievably burn tokens.
    address public constant BURN_ADDRESS =
        0x000000000000000000000000000000000000dEaD;
    /// @notice Default portion of a job's payout to burn (5% = 500 basis points).
    uint256 public constant BURN_PERCENTAGE = 500;
    /// @notice Destination for burned tokens. Owner may update if needed.
    address public burnAddress = BURN_ADDRESS;
    /// @notice Portion of a job's payout (in basis points) to destroy on completion.
    uint256 public burnPercentage = BURN_PERCENTAGE;
    /// @notice Recipient of slashed validator stakes when no correct votes exist.
    address public slashedStakeRecipient;
    /// @notice Denominator used for percentage calculations (100% = 10_000).
    uint256 public constant PERCENTAGE_DENOMINATOR = 10_000;
    /// @notice Duration of the commit phase for validator votes.
    /// @dev Defaults to 1 hour and may be updated by the owner.
    uint256 public commitDuration;
    /// @notice Duration of the reveal phase following commits.
    /// @dev Defaults to 1 hour and may be updated by the owner.
    uint256 public revealDuration;
    /// @notice Waiting period after completion request before validators may vote.
    uint256 public reviewWindow;

    /// @notice Tracks the lifecycle of a job.
    enum JobStatus {
        Open,
        CompletionRequested,
        Disputed,
        Completed
    }

    struct Job {
        uint256 id;
        address employer;
        string ipfsHash;
        uint256 payout;
        uint256 duration;
        address assignedAgent;
        uint256 assignedAt;
        JobStatus status;
        uint256 completionRequestedAt; // timestamp when completion was requested
        uint256 validatorApprovals;
        uint256 validatorDisapprovals;
        string details;
        mapping(address => bool) approvals;
        mapping(address => bool) disapprovals;
        address[] validators;
        address[] selectedValidators;
        mapping(address => bool) isSelectedValidator;
        mapping(address => bool) committed;
        mapping(address => bytes32) commitments;
        mapping(address => bool) revealed;
        mapping(address => bool) revealedVotes;
        uint256 validationStart;
    }

    struct AGIType {
        address nftAddress;
        uint256 payoutPercentage; // bonus in basis points
    }

    struct Listing {
        uint256 tokenId;
        address seller;
        uint256 price;
        bool isActive;
    }

    enum DisputeOutcome {
        AgentWin,
        EmployerWin
    }

    uint256 public nextJobId;
    uint256 public nextTokenId;
    mapping(uint256 => Job) public jobs;
    mapping(address => uint256) public reputation;
    mapping(address => uint256) public validatorStake;
    mapping(address => uint256) public pendingCommits;
    mapping(address => bool) public moderators;
    mapping(address => bool) public additionalValidators;
    mapping(address => bool) public additionalAgents;
    mapping(address => uint256[]) public validatorApprovedJobs;
    mapping(address => uint256[]) public validatorDisapprovedJobs;
    mapping(address => mapping(uint256 => uint256))
        private validatorApprovedJobIndex;
    mapping(address => mapping(uint256 => uint256))
        private validatorDisapprovedJobIndex;
    mapping(uint256 => Listing) public listings;
    mapping(address => bool) public blacklistedAgents;
    mapping(address => bool) public blacklistedValidators;
    uint256 public totalJobEscrow;
    uint256 public totalValidatorStake;
    uint256 public constant MAX_AGI_TYPES = 50; // limits AGI type iterations
    AGIType[] public agiTypes;

    event JobCreated(
        uint256 indexed jobId,
        string ipfsHash,
        uint256 payout,
        uint256 duration,
        string details,
        JobStatus status
    );
    event JobApplied(uint256 indexed jobId, address indexed agent);
    event JobCompletionRequested(
        uint256 indexed jobId,
        address indexed agent,
        JobStatus status
    );
    event JobValidated(uint256 indexed jobId, address indexed validator);
    event JobDisapproved(uint256 indexed jobId, address indexed validator);
    event JobCompleted(
        uint256 indexed jobId,
        address indexed agent,
        uint256 reputationPoints,
        JobStatus status
    );
    event ValidationCommitted(
        uint256 indexed jobId,
        address indexed validator,
        bytes32 commitment
    );
    event ValidationRevealed(
        uint256 indexed jobId,
        address indexed validator,
        bool approved
    );
    event ValidatorsSelected(uint256 indexed jobId, address[] validators);
    event CommitRevealWindowsUpdated(uint256 commitWindow, uint256 revealWindow);
    event ReviewWindowUpdated(uint256 newWindow);
    event JobFinalizedAndBurned(
        uint256 indexed jobId,
        address indexed agent,
        address indexed employer,
        uint256 payoutToAgent,
        uint256 tokensBurned
    );
    event ReputationUpdated(address indexed user, uint256 newReputation);
    event JobCancelled(uint256 indexed jobId);
    event JobTimedOut(
        uint256 indexed jobId,
        address indexed employer,
        JobStatus status
    );
    event DisputeResolved(
        uint256 indexed jobId,
        address indexed resolver,
        DisputeOutcome outcome
    );
    event JobDisputed(
        uint256 indexed jobId,
        address indexed disputant,
        JobStatus status
    );
    event ClubRootNodeUpdated(bytes32 indexed newClubRootNode);
    event AgentRootNodeUpdated(bytes32 indexed newAgentRootNode);
    event ValidatorMerkleRootUpdated(bytes32 indexed newValidatorMerkleRoot);
    event AgentMerkleRootUpdated(bytes32 indexed newAgentMerkleRoot);
    event ENSAddressUpdated(address indexed newEnsAddress);
    event NameWrapperAddressUpdated(address indexed newNameWrapperAddress);
    event OwnershipVerified(address indexed claimant, string subdomain);
    event RecoveryInitiated(string reason);
    event AGITypeUpdated(address indexed nftAddress, uint256 payoutPercentage);
    event AGITypeRemoved(address indexed nftAddress);
    event NFTIssued(uint256 indexed tokenId, address indexed employer, string tokenURI);
    event NFTListed(uint256 indexed tokenId, address indexed seller, uint256 price);
    event NFTPurchased(uint256 indexed tokenId, address indexed buyer, uint256 price);
    event NFTDelisted(uint256 indexed tokenId);
    event RewardPoolContribution(address indexed contributor, uint256 amount);
    event AgentBlacklisted(address indexed agent, bool status);
    event ValidatorBlacklisted(address indexed validator, bool status);
    /// @notice Emitted when a validator is manually added outside the Merkle allowlist.
    event AdditionalValidatorAdded(address indexed validator);
    /// @notice Emitted when a validator is removed from the additional allowlist or rotating pool.
    event ValidatorRemoved(address indexed validator);
    /// @notice Emitted when an agent is manually whitelisted outside the Merkle allowlist.
    event AdditionalAgentAdded(address indexed agent);
    /// @notice Emitted when an agent is removed from the additional allowlist.
    event AdditionalAgentRemoved(address indexed agent);
    /// @notice Emitted when the full validator pool is replaced.
    event ValidatorPoolSet(address[] newValidators);
    /// @notice Emitted when the maximum validator pool size changes.
    event MaxValidatorPoolSizeUpdated(uint256 oldSize, uint256 newSize);
    event ModeratorAdded(address indexed moderator);
    event ModeratorRemoved(address indexed moderator);
    event AGITokenAddressUpdated(address indexed newTokenAddress);
    event BaseURIUpdated(string newBaseURI);
    event RequiredValidatorApprovalsUpdated(uint256 newApprovals);
    event RequiredValidatorDisapprovalsUpdated(uint256 newDisapprovals);
    event PremiumReputationThresholdUpdated(uint256 newThreshold);
    event MaxJobPayoutUpdated(uint256 newMaxPayout);
    event JobDurationLimitUpdated(uint256 newLimit);
    event TermsAndConditionsIpfsHashUpdated(string newHash);
    event ContactEmailUpdated(string newEmail);
    event AdditionalText1Updated(string newText);
    event AdditionalText2Updated(string newText);
    event AdditionalText3Updated(string newText);
    event BurnAddressUpdated(address indexed newBurnAddress);
    /// @notice Emitted when the slashed stake recipient is updated.
    event SlashedStakeRecipientUpdated(address indexed newRecipient);
    /// @notice Emitted when the burn percentage is updated.
    event BurnPercentageUpdated(uint256 newPercentage);
    /// @notice Emitted when the validation reward percentage is updated.
    event ValidationRewardPercentageUpdated(uint256 newPercentage);
    /// @notice Emitted when the validator reputation percentage is updated.
    event ValidatorReputationPercentageUpdated(uint256 newPercentage);
    event ValidatorsPerJobUpdated(uint256 count);
    event StakeDeposited(address indexed validator, uint256 amount);
    event StakeWithdrawn(address indexed validator, uint256 amount);
    event AGIWithdrawn(address indexed owner, uint256 amount);
    event StakeRequirementUpdated(uint256 newRequirement);
    event SlashingPercentageUpdated(uint256 newPercentage);
    event MinValidatorReputationUpdated(uint256 newMinimum);
    event StakeSlashed(address indexed validator, uint256 amount);
    event ValidatorPayout(address indexed validator, uint256 amount);
    event LeftoverTransferred(address indexed recipient, uint256 amount);
    event ValidatorSkipped(
        uint256 indexed jobId,
        address indexed validator,
        bool committed,
        bool revealed
    );
    event ValidatorRewardReduced(
        uint256 indexed jobId,
        uint256 availableSlashed,
        uint256 expectedReward
    );
    event ValidatorConfigUpdated(
        uint256 rewardPercentage,
        uint256 reputationPercentage,
        uint256 stakeRequirement,
        uint256 slashingPercentage,
        uint256 minValidatorReputation,
        uint256 requiredApprovals,
        uint256 requiredDisapprovals,
        address slashedStakeRecipient,
        uint256 commitWindow,
        uint256 revealWindow,
        uint256 reviewWindow,
        uint256 validatorsPerJob
    );

    /// @dev Thrown when an AGI type is added with invalid parameters.
    error InvalidAGITypeParameters();

    /// @dev Thrown when the specified AGI type does not exist.
    error AGITypeNotFound();

    /// @dev Thrown when attempting to add more AGI types than allowed.
    error MaxAGITypesReached();

    /// @dev Thrown when the supplied amount is zero or exceeds the contract balance.
    error InvalidAmount();

    /// @dev Thrown when the burn address has not been configured.
    error BurnAddressNotSet();

    /// @dev Thrown when caller lacks required permissions or is blacklisted.
    error Unauthorized();

    /// @dev Thrown when supplied parameters are invalid.
    error InvalidParameters();

    /// @dev Thrown when an action is not permitted in the job's current state.
    error InvalidJobState();

    /// @dev Thrown when a validator submits more than one commitment.
    error AlreadyCommitted();

    /// @dev Thrown when a validator tries to reveal twice.
    error AlreadyRevealed();

    /// @dev Thrown when reveal data does not match the original commitment.
    error InvalidReveal();

    /// @dev Thrown when the job's duration has elapsed.
    error JobExpired();

    /// @dev Thrown when an employer attempts to timeout before expiration.
    error JobNotExpired();

    /// @dev Thrown when a job is not in the expected open state.
    error JobNotOpen();

    /// @dev Thrown when an agent tries to submit after a timeout.
    error JobTimedOutAlready();

    /// @dev Thrown when there are insufficient validators available for selection.
    error NotEnoughValidators();

    /// @dev Thrown when a validator's stake is below the required minimum.
    error InsufficientStake();

    /// @dev Thrown when a validator's reputation is below the threshold.
    error InsufficientReputation();

    /// @dev Thrown when a validator is not selected for a job.
    error ValidatorNotSelected();

    /// @dev Thrown when committing after the commit phase has elapsed.
    error CommitPhaseOver();

    /// @dev Thrown when revealing before the reveal phase begins.
    error RevealPhaseNotStarted();

    /// @dev Thrown when revealing after the reveal phase has ended.
    error RevealPhaseOver();

    /// @dev Thrown when a validator attempts to reveal without committing.
    error CommitmentMissing();

    /// @dev Thrown when a validator attempts to finalize without revealing.
    error VoteNotRevealed();

    /// @dev Thrown when validation is attempted while the review window is active.
    error ReviewWindowActive();

    /// @dev Thrown when validation is attempted during the reveal phase.
    error RevealPhaseActive();

    /// @dev Thrown when disputing before required windows have elapsed.
    error PrematureDispute();

    /// @dev Thrown when a validator's revealed vote does not match the action.
    error CommitmentMismatch();

    /// @dev Thrown when attempting to finalize an already completed job.
    error JobAlreadyFinalized();

    /// @dev Thrown when a job has not requested completion before finalization.
    error CompletionNotRequested();

    /// @dev Thrown when a job fails validation checks prior to finalization.
    error JobNotValidated();

    /// @dev Thrown when a referenced job cannot be found.
    error JobDoesNotExist();

    /// @dev Thrown when an address parameter is the zero address.
    error InvalidAddress();

    /// @dev Thrown when a percentage parameter exceeds the denominator.
    error InvalidPercentage();

    /// @dev Thrown when combined payout percentages exceed 100%.
    error InvalidPercentageCombination();

    /// @dev Thrown when a numeric count is out of range or zero.
    error InvalidCount();

    /// @dev Thrown when a duration parameter is zero.
    error InvalidDuration();

    /// @dev Thrown when approval thresholds are misconfigured.
    error InvalidApprovals();

    /// @dev Thrown when disapproval thresholds are misconfigured.
    error InvalidDisapprovals();

    /// @dev Thrown when attempting to list an already listed NFT.
    error ListingAlreadyActive();

    /// @dev Thrown when a seller tries to purchase their own NFT.
    error SelfPurchase();

    /// @dev Thrown when attempting to remove a validator that is unknown.
    error ValidatorNotFound();

    /// @dev Thrown when a validator address appears more than once in the pool.
    error DuplicateValidator();

    /// @dev Thrown when the validator pool exceeds `maxValidatorPoolSize`.
    error ValidatorPoolFull();

    /// @dev Thrown when stake withdrawal is blocked by active or disputed jobs.
    error PendingOrDisputedJob();

    /// @dev Thrown when stake withdrawal is blocked by pending commitments.
    error PendingCommitments();

    /// @dev Thrown when remaining stake drops below the required minimum.
    error StakeBelowRequirement();

    /// @dev Thrown when review window is too short for commit and reveal phases.
    error ReviewWindowTooShort();

    /// @dev Thrown when review window is below commit+reveal durations.
    error WindowBelowCommitReveal();

    /// @dev Thrown when payout accounting exceeds escrowed funds.
    error PayoutExceedsEscrow();

    constructor(
        address _agiTokenAddress,
        string memory _initialBaseURI,
        address _ensAddress,
        address _nameWrapperAddress,
        bytes32 _clubRootNode,
        bytes32 _agentRootNode,
        bytes32 _validatorMerkleRoot,
        bytes32 _agentMerkleRoot
    ) ERC721("AGIJobs", "Job") Ownable(msg.sender) {
        agiToken = IERC20(_agiTokenAddress);
        baseURI = _initialBaseURI;
        ens = ENS(_ensAddress);
        nameWrapper = NameWrapper(_nameWrapperAddress);
        clubRootNode = _clubRootNode;
        agentRootNode = _agentRootNode;
        validatorMerkleRoot = _validatorMerkleRoot;
        agentMerkleRoot = _agentMerkleRoot;
        slashedStakeRecipient = msg.sender;
        // Set sensible non-zero defaults to avoid inadvertent instant phases.
        commitDuration = 1 hours;
        revealDuration = 1 hours;
        // Ensure the initial review window accommodates both phases.
        reviewWindow = commitDuration + revealDuration;
    }

    function _baseURI() internal view override returns (string memory) {
        return baseURI;
    }

    modifier onlyModerator() {
        if (!moderators[msg.sender]) revert Unauthorized();
        _;
    }

    modifier jobExists(uint256 jobId) {
        if (jobs[jobId].employer == address(0)) revert JobDoesNotExist();
        _;
    }

    function pause() external onlyOwner {
        _pause();
    }

    function unpause() external onlyOwner {
        _unpause();
    }
    /// Job lifecycle overview:
    /// 1. Employer calls `createJob`.
    /// 2. An agent `applyForJob`.
    /// 3. The agent submits results via `requestJobCompletion`, starting the `reviewWindow`.
    /// 4. Validators commit and reveal votes.
    /// 5. After `reviewWindow` elapses, validators call `validateJob` or `disapproveJob`.
    ///    Sufficient approvals finalize the job; enough disapprovals open a dispute.
    function createJob(string memory _ipfsHash, uint256 _payout, uint256 _duration, string memory _details) external whenNotPaused nonReentrant {
        if (
            _payout == 0 ||
            _duration == 0 ||
            _payout > maxJobPayout ||
            _duration > jobDurationLimit
        ) revert InvalidParameters();
        uint256 jobId = nextJobId;
        agiToken.safeTransferFrom(msg.sender, address(this), _payout);
        totalJobEscrow += _payout;
        Job storage job = jobs[jobId];
        job.id = jobId;
        job.employer = msg.sender;
        job.ipfsHash = _ipfsHash;
        job.payout = _payout;
        job.duration = _duration;
        job.details = _details;
        job.status = JobStatus.Open;
        emit JobCreated(jobId, _ipfsHash, _payout, _duration, _details, JobStatus.Open);
        nextJobId = jobId + 1;
    }

    function applyForJob(uint256 _jobId, string memory subdomain, bytes32[] calldata proof)
        external
        whenNotPaused
        nonReentrant
        jobExists(_jobId)
    {
        Job storage job = jobs[_jobId];
        if (job.status != JobStatus.Open) revert JobNotOpen();
        if (job.assignedAgent != address(0)) revert InvalidJobState();
        if (
            !(
                _verifyOwnership(
                    msg.sender,
                    subdomain,
                    proof,
                    agentRootNode
                ) || additionalAgents[msg.sender]
            ) ||
            blacklistedAgents[msg.sender]
        ) revert Unauthorized();
        job.assignedAgent = msg.sender;
        job.assignedAt = block.timestamp;
        emit JobApplied(_jobId, msg.sender);
    }

    /// @notice Agent submits job results and starts the review window.
    function requestJobCompletion(uint256 _jobId, string calldata _ipfsHash)
        external
        whenNotPaused
        jobExists(_jobId)
    {
        Job storage job = jobs[_jobId];
        if (msg.sender != job.assignedAgent) revert Unauthorized();
        if (job.status == JobStatus.Completed) revert JobTimedOutAlready();
        if (block.timestamp > job.assignedAt + job.duration) revert JobExpired();
        if (job.status != JobStatus.Open) revert JobNotOpen();
        if (bytes(_ipfsHash).length == 0) revert InvalidParameters();
        job.ipfsHash = _ipfsHash;
        job.status = JobStatus.CompletionRequested;
        job.validationStart = block.timestamp;
        job.completionRequestedAt = block.timestamp;
        _selectValidators(_jobId);
        emit JobCompletionRequested(
            _jobId,
            msg.sender,
            JobStatus.CompletionRequested
        );
    }

    /// @dev Selects `validatorsPerJob` unique validators pseudo-randomly from the pool.
    ///      Uses blockhash-based entropy; not suitable for high-stakes randomness.
    function _selectValidators(uint256 _jobId) internal jobExists(_jobId) {
        Job storage job = jobs[_jobId];
        uint256 poolLength = validatorPool.length;
        address[] memory pool = new address[](poolLength);
        uint256 eligibleCount;
        for (uint256 i; i < poolLength; ) {
            address validator = validatorPool[i];
            if (
                !blacklistedValidators[validator] &&
                validatorStake[validator] >= stakeRequirement &&
                reputation[validator] >= minValidatorReputation
            ) {
                pool[eligibleCount] = validator;
                unchecked {
                    ++eligibleCount;
                }
            }
            unchecked {
                ++i;
            }
        }
        if (eligibleCount < validatorsPerJob) revert NotEnoughValidators();
        assembly {
            mstore(pool, eligibleCount)
        }

        address[] memory selected = new address[](validatorsPerJob);
        bytes32 seed = keccak256(
            abi.encodePacked(blockhash(block.number - 1), _jobId)
        );
        uint256 remaining = pool.length;

        for (uint256 i; i < validatorsPerJob; ) {
            seed = keccak256(abi.encodePacked(seed, i));
            uint256 index = uint256(seed) % remaining;
            address validator = pool[index];
            job.isSelectedValidator[validator] = true;
            job.selectedValidators.push(validator);
            pendingCommits[validator] += 1;
            selected[i] = validator;
            pool[index] = pool[--remaining];
            unchecked {
                ++i;
            }
        }

        emit ValidatorsSelected(_jobId, selected);
    }

    /// @notice Commit to a validation vote without revealing it.
    /// @param _jobId Identifier of the job being validated.
    /// @param commitment Hash of the vote and salt.
    function commitValidation(
        uint256 _jobId,
        bytes32 commitment,
        string memory subdomain,
        bytes32[] calldata proof
    )
        external
        whenNotPaused
        nonReentrant
        jobExists(_jobId)
    {
        if (
            !(
                _verifyOwnership(msg.sender, subdomain, proof, clubRootNode) ||
                    additionalValidators[msg.sender]
            ) ||
            blacklistedValidators[msg.sender]
        ) revert Unauthorized();
        if (validatorStake[msg.sender] < stakeRequirement)
            revert InsufficientStake();
        if (reputation[msg.sender] < minValidatorReputation)
            revert InsufficientReputation();
        Job storage job = jobs[_jobId];
        if (!job.isSelectedValidator[msg.sender]) revert ValidatorNotSelected();
        if (job.status != JobStatus.CompletionRequested) revert InvalidJobState();
        if (block.timestamp > job.validationStart + commitDuration)
            revert CommitPhaseOver();
        if (job.commitments[msg.sender] != bytes32(0)) revert AlreadyCommitted();
        job.commitments[msg.sender] = commitment;
        job.validators.push(msg.sender);
        job.committed[msg.sender] = true;
        emit ValidationCommitted(_jobId, msg.sender, commitment);
    }

    /// @notice Reveal a previously committed vote.
    /// @param _jobId Identifier of the job being validated.
    /// @param approve True to approve, false to disapprove.
    /// @param salt Random value used during commit.
    function revealValidation(
        uint256 _jobId,
        bool approve,
        bytes32 salt
    )
        external
        whenNotPaused
        nonReentrant
        jobExists(_jobId)
    {
        Job storage job = jobs[_jobId];
        if (!job.isSelectedValidator[msg.sender]) revert ValidatorNotSelected();
        if (job.status != JobStatus.CompletionRequested) revert InvalidJobState();
        if (block.timestamp <= job.validationStart + commitDuration)
            revert RevealPhaseNotStarted();
        if (
            block.timestamp >
            job.validationStart + commitDuration + revealDuration
        ) revert RevealPhaseOver();
        bytes32 commitment = job.commitments[msg.sender];
        if (commitment == bytes32(0)) revert CommitmentMissing();
        if (job.revealed[msg.sender]) revert AlreadyRevealed();
        bytes32 expected = keccak256(
            abi.encodePacked(msg.sender, _jobId, approve, salt)
        );
        if (expected != commitment) revert InvalidReveal();
        job.revealed[msg.sender] = true;
        job.revealedVotes[msg.sender] = approve;
        emit ValidationRevealed(_jobId, msg.sender, approve);
    }

    /// @notice Approve a job's completion after the review window has elapsed.
    /// @dev Only validators with sufficient stake and reputation may vote.
    ///      Rewards are paid only to validators whose approvals match the final
    ///      outcome; incorrect approvals are slashed and lose reputation.
    function validateJob(uint256 _jobId, string memory subdomain, bytes32[] calldata proof)
        external
        whenNotPaused
        nonReentrant
        jobExists(_jobId)
    {
        if (
            !(
                _verifyOwnership(msg.sender, subdomain, proof, clubRootNode) ||
                    additionalValidators[msg.sender]
            ) ||
            blacklistedValidators[msg.sender]
        ) revert Unauthorized();
        if (validatorStake[msg.sender] < stakeRequirement)
            revert InsufficientStake();
        if (reputation[msg.sender] < minValidatorReputation)
            revert InsufficientReputation();
        Job storage job = jobs[_jobId];
        if (job.status != JobStatus.CompletionRequested) revert InvalidJobState();
        if (block.timestamp < job.completionRequestedAt + reviewWindow)
            revert ReviewWindowActive();
        if (
            block.timestamp <=
            job.validationStart + commitDuration + revealDuration
        ) revert RevealPhaseActive();
        if (!job.revealed[msg.sender]) revert VoteNotRevealed();
        if (!job.revealedVotes[msg.sender]) revert CommitmentMismatch();
        if (
            job.status == JobStatus.Completed ||
            job.approvals[msg.sender] ||
            job.disapprovals[msg.sender]
        ) revert InvalidJobState();
        job.validatorApprovals++;
        job.approvals[msg.sender] = true;
        _addValidatorApprovedJob(msg.sender, _jobId);
        emit JobValidated(_jobId, msg.sender);
        if (job.validatorApprovals >= requiredValidatorApprovals) {
            _finalizeJobAndBurn(_jobId);
        }
    }

    /// @notice Reject a job's completion after the review window has elapsed.
    /// @dev Misaligned disapprovals are slashed and penalized. Validators voting
    ///      with the ultimate outcome share the reward pool and any slashed stake.
    function disapproveJob(uint256 _jobId, string memory subdomain, bytes32[] calldata proof)
        external
        whenNotPaused
        nonReentrant
        jobExists(_jobId)
    {
        if (
            !(
                _verifyOwnership(msg.sender, subdomain, proof, clubRootNode) ||
                    additionalValidators[msg.sender]
            ) ||
            blacklistedValidators[msg.sender]
        ) revert Unauthorized();
        if (validatorStake[msg.sender] < stakeRequirement)
            revert InsufficientStake();
        if (reputation[msg.sender] < minValidatorReputation)
            revert InsufficientReputation();
        Job storage job = jobs[_jobId];
        if (job.status != JobStatus.CompletionRequested) revert InvalidJobState();
        if (block.timestamp < job.completionRequestedAt + reviewWindow)
            revert ReviewWindowActive();
        if (
            block.timestamp <=
            job.validationStart + commitDuration + revealDuration
        ) revert RevealPhaseActive();
        if (!job.revealed[msg.sender]) revert VoteNotRevealed();
        if (job.revealedVotes[msg.sender]) revert CommitmentMismatch();
        if (job.status == JobStatus.Completed || job.disapprovals[msg.sender])
            revert InvalidJobState();
        if (job.approvals[msg.sender]) revert InvalidJobState();
        job.validatorDisapprovals++;
        job.disapprovals[msg.sender] = true;
        _addValidatorDisapprovedJob(msg.sender, _jobId);
        emit JobDisapproved(_jobId, msg.sender);
        if (job.validatorDisapprovals >= requiredValidatorDisapprovals) {
            job.status = JobStatus.Disputed;
            emit JobDisputed(_jobId, msg.sender, JobStatus.Disputed);
        }
    }

    function disputeJob(uint256 _jobId)
        external
        whenNotPaused
        nonReentrant
        jobExists(_jobId)
    {
        Job storage job = jobs[_jobId];
        if (
            (msg.sender != job.assignedAgent && msg.sender != job.employer) ||
            job.status == JobStatus.Disputed ||
            job.status == JobStatus.Completed
        ) revert Unauthorized();
        if (
            block.timestamp < job.completionRequestedAt + reviewWindow ||
            block.timestamp <=
                job.validationStart + commitDuration + revealDuration
        ) revert PrematureDispute();
        job.status = JobStatus.Disputed;
        emit JobDisputed(_jobId, msg.sender, JobStatus.Disputed);
    }

    function resolveDispute(uint256 _jobId, DisputeOutcome outcome)
        external
        nonReentrant
        onlyModerator
        jobExists(_jobId)
    {
        Job storage job = jobs[_jobId];
        if (job.status != JobStatus.Disputed) revert InvalidJobState();
        if (outcome == DisputeOutcome.AgentWin) {
            _finalizeJobAndBurn(_jobId);
        } else if (outcome == DisputeOutcome.EmployerWin) {
            _resolveEmployerWin(_jobId);
        }
        emit DisputeResolved(_jobId, msg.sender, outcome);
    }

    function _resolveEmployerWin(uint256 _jobId) internal {
        Job storage job = jobs[_jobId];
        job.status = JobStatus.Completed;
        totalJobEscrow -= job.payout;
        uint256 validatorPayoutTotal =
            (job.payout * validationRewardPercentage) /
            PERCENTAGE_DENOMINATOR;
        uint256 completionTime = block.timestamp - job.assignedAt;
        uint256 reputationPoints =
            calculateReputationPoints(job.payout, completionTime);
        uint256 validatorReputationChange =
            calculateValidatorReputationPoints(reputationPoints);
        uint256 correctValidatorCount = job.validatorDisapprovals;
        address[] memory correctValidators =
            new address[](correctValidatorCount);
        uint256 correctIndex = 0;
        uint256 totalSlashed = 0;

        uint256 svLen = job.selectedValidators.length;
        for (uint256 i; i < svLen; ) {
            address validator = job.selectedValidators[i];
            bool committed = job.committed[validator];
            bool revealed = job.revealed[validator];
            if (committed && revealed && job.disapprovals[validator]) {
                _removeValidatorDisapprovedJob(validator, _jobId);
                correctValidators[correctIndex++] = validator;
                enforceReputationGrowth(validator, validatorReputationChange);
            } else if (committed && revealed && job.approvals[validator]) {
                _removeValidatorApprovedJob(validator, _jobId);
                uint256 slashAmount =
                    (validatorStake[validator] * slashingPercentage) /
                    PERCENTAGE_DENOMINATOR;
                if (slashAmount > 0) {
                    validatorStake[validator] -= slashAmount;
                    totalValidatorStake -= slashAmount;
                    totalSlashed += slashAmount;
                    emit StakeSlashed(validator, slashAmount);
                }
                enforceReputationPenalty(validator, validatorReputationChange);
            } else if (committed && revealed) {
                _removeValidatorApprovedJob(validator, _jobId);
                _removeValidatorDisapprovedJob(validator, _jobId);
                uint256 slashAmount =
                    (validatorStake[validator] * slashingPercentage) /
                    PERCENTAGE_DENOMINATOR;
                if (slashAmount > 0) {
                    validatorStake[validator] -= slashAmount;
                    totalValidatorStake -= slashAmount;
                    totalSlashed += slashAmount;
                    emit StakeSlashed(validator, slashAmount);
                }
                enforceReputationPenalty(validator, validatorReputationChange);
            } else {
                _removeValidatorApprovedJob(validator, _jobId);
                _removeValidatorDisapprovedJob(validator, _jobId);
                uint256 slashAmount =
                    (validatorStake[validator] * slashingPercentage) /
                    PERCENTAGE_DENOMINATOR;
                if (slashAmount > 0) {
                    validatorStake[validator] -= slashAmount;
                    totalValidatorStake -= slashAmount;
                    totalSlashed += slashAmount;
                    emit StakeSlashed(validator, slashAmount);
                }
                emit ValidatorSkipped(_jobId, validator, committed, revealed);
            }
            if (pendingCommits[validator] > 0) {
                pendingCommits[validator] -= 1;
            }
            delete job.approvals[validator];
            delete job.disapprovals[validator];
            delete job.commitments[validator];
            delete job.revealed[validator];
            delete job.revealedVotes[validator];
            delete job.committed[validator];
            unchecked {
                ++i;
            }
        }

        delete job.validators;
        for (uint256 i; i < svLen; ) {
            delete job.isSelectedValidator[job.selectedValidators[i]];
            unchecked {
                ++i;
            }
        }
        delete job.selectedValidators;

        if (correctValidatorCount > 0) {
            uint256 rewardCap = validatorPayoutTotal;
            if (totalSlashed < rewardCap) {
                rewardCap = totalSlashed;
                emit ValidatorRewardReduced(
                    _jobId,
                    totalSlashed,
                    validatorPayoutTotal
                );
            }
            uint256 rewardPerValidator = rewardCap / correctValidatorCount;
            uint256 distributed = rewardPerValidator * correctValidatorCount;
            uint256 leftover = totalSlashed - distributed;
            for (uint256 i = 0; i < correctValidators.length; i++) {
                if (rewardPerValidator > 0) {
                    agiToken.safeTransfer(
                        correctValidators[i],
                        rewardPerValidator
                    );
                    emit ValidatorPayout(
                        correctValidators[i],
                        rewardPerValidator
                    );
                }
            }
            if (leftover > 0) {
                agiToken.safeTransfer(slashedStakeRecipient, leftover);
                emit LeftoverTransferred(slashedStakeRecipient, leftover);
            }
        } else {
            if (totalSlashed > 0) {
                agiToken.safeTransfer(slashedStakeRecipient, totalSlashed);
            }
        }
        agiToken.safeTransfer(job.employer, job.payout);
    }

    function blacklistAgent(address _agent, bool _status) external onlyOwner {
        blacklistedAgents[_agent] = _status;
        emit AgentBlacklisted(_agent, _status);
    }

    function blacklistValidator(address _validator, bool _status) external onlyOwner {
        blacklistedValidators[_validator] = _status;
        emit ValidatorBlacklisted(_validator, _status);
    }

    function delistJob(uint256 _jobId)
        external
        onlyOwner
        nonReentrant
        jobExists(_jobId)
    {
        Job storage job = jobs[_jobId];
        if (job.status != JobStatus.Open || job.assignedAgent != address(0))
            revert InvalidJobState();
        address employer = job.employer;
        uint256 payout = job.payout;
        delete jobs[_jobId];
        totalJobEscrow -= payout;
        agiToken.safeTransfer(employer, payout);
        emit JobCancelled(_jobId);
    }

    function addModerator(address _moderator) external onlyOwner {
        moderators[_moderator] = true;
        emit ModeratorAdded(_moderator);
    }

    function removeModerator(address _moderator) external onlyOwner {
        moderators[_moderator] = false;
        emit ModeratorRemoved(_moderator);
    }

    function updateAGITokenAddress(address _newTokenAddress) external onlyOwner {
        if (_newTokenAddress == address(0)) revert InvalidAddress();
        agiToken = IERC20(_newTokenAddress);
        emit AGITokenAddressUpdated(_newTokenAddress);
    }

    function setBaseURI(string calldata _newBaseURI) external onlyOwner {
        baseURI = _newBaseURI;
        emit BaseURIUpdated(_newBaseURI);
    }

    function setRequiredValidatorApprovals(uint256 _approvals) external onlyOwner {
        if (_approvals == 0 || _approvals > validatorsPerJob)
            revert InvalidApprovals();
        requiredValidatorApprovals = _approvals;
        emit RequiredValidatorApprovalsUpdated(_approvals);
    }

    function setRequiredValidatorDisapprovals(uint256 _disapprovals) external onlyOwner {
        if (_disapprovals == 0 || _disapprovals > validatorsPerJob)
            revert InvalidDisapprovals();
        requiredValidatorDisapprovals = _disapprovals;
        emit RequiredValidatorDisapprovalsUpdated(_disapprovals);
    }

    function setPremiumReputationThreshold(uint256 _threshold) external onlyOwner {
        premiumReputationThreshold = _threshold;
        emit PremiumReputationThresholdUpdated(_threshold);
    }

    function setMaxJobPayout(uint256 _maxPayout) external onlyOwner {
        maxJobPayout = _maxPayout;
        emit MaxJobPayoutUpdated(_maxPayout);
    }

    function setJobDurationLimit(uint256 _limit) external onlyOwner {
        jobDurationLimit = _limit;
        emit JobDurationLimitUpdated(_limit);
    }

    function updateTermsAndConditionsIpfsHash(string calldata _hash) external onlyOwner {
        termsAndConditionsIpfsHash = _hash;
        emit TermsAndConditionsIpfsHashUpdated(_hash);
    }

    function updateContactEmail(string calldata _email) external onlyOwner {
        contactEmail = _email;
        emit ContactEmailUpdated(_email);
    }

    function updateAdditionalText1(string calldata _text) external onlyOwner {
        additionalText1 = _text;
        emit AdditionalText1Updated(_text);
    }

    function updateAdditionalText2(string calldata _text) external onlyOwner {
        additionalText2 = _text;
        emit AdditionalText2Updated(_text);
    }

    function updateAdditionalText3(string calldata _text) external onlyOwner {
        additionalText3 = _text;
        emit AdditionalText3Updated(_text);
    }

    function setClubRootNode(bytes32 newClubRootNode) external onlyOwner {
        clubRootNode = newClubRootNode;
        emit ClubRootNodeUpdated(newClubRootNode);
    }

    function setAgentRootNode(bytes32 newAgentRootNode) external onlyOwner {
        agentRootNode = newAgentRootNode;
        emit AgentRootNodeUpdated(newAgentRootNode);
    }

    function setValidatorMerkleRoot(bytes32 newValidatorMerkleRoot) external onlyOwner {
        validatorMerkleRoot = newValidatorMerkleRoot;
        emit ValidatorMerkleRootUpdated(newValidatorMerkleRoot);
    }

    function setAgentMerkleRoot(bytes32 newAgentMerkleRoot) external onlyOwner {
        agentMerkleRoot = newAgentMerkleRoot;
        emit AgentMerkleRootUpdated(newAgentMerkleRoot);
    }

    function setENS(address newEnsAddress) external onlyOwner {
        if (newEnsAddress == address(0)) revert InvalidAddress();
        ens = ENS(newEnsAddress);
        emit ENSAddressUpdated(newEnsAddress);
    }

    function setNameWrapper(address newNameWrapperAddress) external onlyOwner {
        if (newNameWrapperAddress == address(0)) revert InvalidAddress();
        nameWrapper = NameWrapper(newNameWrapperAddress);
        emit NameWrapperAddressUpdated(newNameWrapperAddress);
    }

    function getJobStatus(uint256 _jobId)
        external
        view
        jobExists(_jobId)
        returns (JobStatus, string memory)
    {
        Job storage job = jobs[_jobId];
        return (job.status, job.ipfsHash);
    }

    /// @notice Retrieve comprehensive job details.
    /// @param _jobId Identifier of the job.
    /// @return id Job identifier.
    /// @return employer Job creator address.
    /// @return ipfsHash IPFS hash of job details or results.
    /// @return payout Escrowed payout amount.
    /// @return duration Job duration in seconds.
    /// @return assignedAgent Agent assigned to the job.
    /// @return assignedAt Timestamp when the agent was assigned.
    /// @return status Current job status.
    /// @return completionRequestedAt Timestamp when completion was requested.
    /// @return validatorApprovals Number of validator approvals.
    /// @return validatorDisapprovals Number of validator disapprovals.
    /// @return details Additional job description.
    function getJobInfo(uint256 _jobId)
        external
        view
        jobExists(_jobId)
        returns (
            uint256 id,
            address employer,
            string memory ipfsHash,
            uint256 payout,
            uint256 duration,
            address assignedAgent,
            uint256 assignedAt,
            JobStatus status,
            uint256 completionRequestedAt,
            uint256 validatorApprovals,
            uint256 validatorDisapprovals,
            string memory details
        )
    {
        Job storage job = jobs[_jobId];
        return (
            job.id,
            job.employer,
            job.ipfsHash,
            job.payout,
            job.duration,
            job.assignedAgent,
            job.assignedAt,
            job.status,
            job.completionRequestedAt,
            job.validatorApprovals,
            job.validatorDisapprovals,
            job.details
        );
    }

    /// @notice Retrieve validators that committed to a job.
    function getJobValidators(uint256 _jobId)
        external
        view
        jobExists(_jobId)
        returns (address[] memory)
    {
        return jobs[_jobId].validators;
    }

    /// @notice Retrieve validators selected for a job.
    function getSelectedValidators(uint256 _jobId)
        external
        view
        jobExists(_jobId)
        returns (address[] memory)
    {
        return jobs[_jobId].selectedValidators;
    }

    function _validatePayoutSplits(
        uint256 _burnPercentage,
        uint256 _validationRewardPercentage
    ) internal pure {
        if (_burnPercentage + _validationRewardPercentage > PERCENTAGE_DENOMINATOR)
            revert InvalidPercentageCombination();
    }

    /// @notice Update the percentage of job payout allocated to validators.
    /// @param _percentage New reward percentage for validators in basis points.
    /// @dev Setting `_percentage` to 0 disables validator rewards.
    function setValidationRewardPercentage(uint256 _percentage) external onlyOwner {
        if (_percentage > PERCENTAGE_DENOMINATOR) revert InvalidPercentage();
        _validatePayoutSplits(burnPercentage, _percentage);
        validationRewardPercentage = _percentage;
        emit ValidationRewardPercentageUpdated(_percentage);
    }

    /// @notice Update the percentage of agent reputation granted to correct validators.
    /// @param _percentage Reputation share for validators in basis points.
    /// @dev Setting `_percentage` to 0 disables validator reputation gains.
    function setValidatorReputationPercentage(uint256 _percentage) external onlyOwner {
        if (_percentage > PERCENTAGE_DENOMINATOR) revert InvalidPercentage();
        validatorReputationPercentage = _percentage;
        emit ValidatorReputationPercentageUpdated(_percentage);
    }

    /// @notice Update burn rate in basis points.
    /// @dev Setting `newPercentage` to 0 disables burning.
    function setBurnPercentage(uint256 newPercentage) external onlyOwner {
        if (newPercentage > PERCENTAGE_DENOMINATOR) revert InvalidPercentage();
        _validatePayoutSplits(newPercentage, validationRewardPercentage);
        burnPercentage = newPercentage;
        emit BurnPercentageUpdated(newPercentage);
    }

    function setBurnAddress(address newBurnAddress) external onlyOwner {
        if (newBurnAddress == address(0)) revert InvalidAddress();
        burnAddress = newBurnAddress;
        emit BurnAddressUpdated(newBurnAddress);
    }

    /// @notice Atomically update burn address and percentage.
    /// @param newBurnAddress Destination for burned tokens.
    /// @param newPercentage Portion of payout (in basis points) to burn.
    function setBurnConfig(
        address newBurnAddress,
        uint256 newPercentage
    ) external onlyOwner {
        if (newBurnAddress == address(0)) revert InvalidAddress();
        if (newPercentage > PERCENTAGE_DENOMINATOR) revert InvalidPercentage();
        burnAddress = newBurnAddress;
        burnPercentage = newPercentage;
        emit BurnAddressUpdated(newBurnAddress);
        emit BurnPercentageUpdated(newPercentage);
    }

    function setSlashedStakeRecipient(address newRecipient) external onlyOwner {
        if (newRecipient == address(0)) revert InvalidAddress();
        slashedStakeRecipient = newRecipient;
        emit SlashedStakeRecipientUpdated(newRecipient);
    }

    /// @notice Update the minimum stake validators must maintain.
    /// @dev Setting `amount` to 0 removes the staking requirement entirely.
    function setStakeRequirement(uint256 amount) external onlyOwner {
        stakeRequirement = amount;
        emit StakeRequirementUpdated(amount);
    }

    /// @notice Update the slashing rate applied to incorrect validator stakes.
    /// @param percentage Portion of staked tokens to slash in basis points.
    /// @dev Setting `percentage` to 0 disables slashing.
    function setSlashingPercentage(uint256 percentage) external onlyOwner {
        if (percentage > PERCENTAGE_DENOMINATOR) revert InvalidPercentage();
        slashingPercentage = percentage;
        emit SlashingPercentageUpdated(percentage);
    }

    function setMinValidatorReputation(uint256 minimum) external onlyOwner {
        minValidatorReputation = minimum;
        emit MinValidatorReputationUpdated(minimum);
    }

    function setValidatorsPerJob(uint256 count) external onlyOwner {
        if (
            count == 0 ||
            count < requiredValidatorApprovals ||
            count < requiredValidatorDisapprovals
        ) revert InvalidCount();
        validatorsPerJob = count;
        emit ValidatorsPerJobUpdated(count);
    }

    /// @notice Update the maximum size of the validator pool.
    /// @param newSize The new maximum number of validators allowed.
    function setMaxValidatorPoolSize(uint256 newSize) external onlyOwner {
        if (newSize < validatorPool.length) revert ValidatorPoolFull();
        uint256 oldSize = maxValidatorPoolSize;
        maxValidatorPoolSize = newSize;
        emit MaxValidatorPoolSizeUpdated(oldSize, newSize);
    }

    /// @notice Update commit and reveal window durations.
    /// @param commitWindow Length of the commit phase in seconds; must be greater than zero.
    /// @param revealWindow Length of the reveal phase in seconds; must be greater than zero.
    /// @dev Both `commitWindow` and `revealWindow` must be greater than zero.
    function setCommitRevealWindows(
        uint256 commitWindow,
        uint256 revealWindow
    ) external onlyOwner {
        if (commitWindow == 0 || revealWindow == 0) revert InvalidDuration();
        if (reviewWindow < commitWindow + revealWindow)
            revert ReviewWindowTooShort();
        commitDuration = commitWindow;
        revealDuration = revealWindow;
        emit CommitRevealWindowsUpdated(commitWindow, revealWindow);
    }

    /// @notice Update the mandatory waiting period after completion requests.
    /// @param newWindow Duration in seconds validators must wait to vote.
    function setReviewWindow(uint256 newWindow) external onlyOwner {
        if (newWindow < commitDuration + revealDuration)
            revert WindowBelowCommitReveal();
        reviewWindow = newWindow;
        emit ReviewWindowUpdated(newWindow);
    }

    /// @notice Atomically update validator incentive parameters.
    /// @param rewardPercentage Portion of job payout allocated to correct validators (basis points).
    /// @param reputationPercentage Share of agent reputation granted to correct validators (basis points).
    /// @param stakeReq Minimum stake required to validate (0 disables staking).
    /// @param slashPercentage Portion of incorrect stake to slash (basis points; 0 disables).
    /// @param minRep Minimum reputation required to validate.
    /// @param approvals Validator approvals needed to finalize a job.
    /// @param disapprovals Validator disapprovals needed to dispute a job.
    /// @param slashRecipient Address receiving slashed stake when no validator votes correctly.
    /// @param commitWindow Length of commit phase in seconds; must be greater than zero.
    /// @param revealWindow Length of reveal phase in seconds; must be greater than zero.
    /// @param reviewWin Mandatory waiting period before validators may vote.
    /// @param validatorsCount Number of validators randomly selected per job.
    function setValidatorConfig(
        uint256 rewardPercentage,
        uint256 reputationPercentage,
        uint256 stakeReq,
        uint256 slashPercentage,
        uint256 minRep,
        uint256 approvals,
        uint256 disapprovals,
        address slashRecipient,
        uint256 commitWindow,
        uint256 revealWindow,
        uint256 reviewWin,
        uint256 validatorsCount
    ) external onlyOwner {
        if (
            rewardPercentage > PERCENTAGE_DENOMINATOR ||
            reputationPercentage > PERCENTAGE_DENOMINATOR ||
            slashPercentage > PERCENTAGE_DENOMINATOR
        ) revert InvalidPercentage();
        _validatePayoutSplits(burnPercentage, rewardPercentage);
        if (validatorsCount == 0) revert InvalidCount();
        if (approvals == 0 || approvals > validatorsCount)
            revert InvalidApprovals();
        if (disapprovals == 0 || disapprovals > validatorsCount)
            revert InvalidDisapprovals();
        if (slashRecipient == address(0)) revert InvalidAddress();
        if (commitWindow == 0 || revealWindow == 0) revert InvalidDuration();
        if (reviewWin < commitWindow + revealWindow)
            revert WindowBelowCommitReveal();
        validationRewardPercentage = rewardPercentage;
        validatorReputationPercentage = reputationPercentage;
        stakeRequirement = stakeReq;
        slashingPercentage = slashPercentage;
        minValidatorReputation = minRep;
        requiredValidatorApprovals = approvals;
        requiredValidatorDisapprovals = disapprovals;
        slashedStakeRecipient = slashRecipient;
        commitDuration = commitWindow;
        revealDuration = revealWindow;
        reviewWindow = reviewWin;
        validatorsPerJob = validatorsCount;
        emit ValidatorConfigUpdated(
            rewardPercentage,
            reputationPercentage,
            stakeReq,
            slashPercentage,
            minRep,
            approvals,
            disapprovals,
            slashRecipient,
            commitWindow,
            revealWindow,
            reviewWin,
            validatorsCount
        );
    }

    function calculateReputationPoints(uint256 _payout, uint256 _duration) internal pure returns (uint256) {
        uint256 scaledPayout = _payout / 1e18;
        uint256 payoutPoints = scaledPayout ** 3 / 1e5;
        return log2(1 + payoutPoints * 1e6) + _duration / 10000;
    }

    function calculateValidatorReputationPoints(uint256 agentReputationGain) internal view returns (uint256) {
        return
            (agentReputationGain * validatorReputationPercentage) /
            PERCENTAGE_DENOMINATOR;
    }

    function log2(uint x) internal pure returns (uint y) {
        assembly {
            let arg := x
            x := sub(x, 1)
            x := or(x, div(x, 0x02))
            x := or(x, div(x, 0x04))
            x := or(x, div(x, 0x10))
            x := or(x, div(x, 0x100))
            x := or(x, div(x, 0x10000))
            x := or(x, div(x, 0x100000000))
            x := or(x, div(x, 0x10000000000000000))
            x := or(x, div(x, 0x100000000000000000000000000000000))
            x := add(x, 1)
            y := 0
            for { let shift := 128 } gt(shift, 0) { shift := div(shift, 2) } {
                let temp := shr(shift, x)
                if gt(temp, 0) {
                    x := temp
                    y := add(y, shift)
                }
            }
        }
    }

    function enforceReputationGrowth(address _user, uint256 _points) internal {
        uint256 currentReputation = reputation[_user];
        uint256 newReputation = currentReputation + _points;

        // Apply diminishing return: soft at low, strong near max
        uint256 diminishingFactor = 1 + ((newReputation * newReputation) / (88888 * 88888));
        uint256 diminishedReputation = newReputation / diminishingFactor;

        if (diminishedReputation > 88888) {
            reputation[_user] = 88888;
        } else {
            reputation[_user] = diminishedReputation;
        }
        emit ReputationUpdated(_user, reputation[_user]);
        if (
            blacklistedValidators[_user] &&
            reputation[_user] >= minValidatorReputation
        ) {
            blacklistedValidators[_user] = false;
            emit ValidatorBlacklisted(_user, false);
        }
    }

    function enforceReputationPenalty(address _user, uint256 _points) internal {
        uint256 currentReputation = reputation[_user];
        if (_points >= currentReputation) {
            reputation[_user] = 0;
        } else {
            reputation[_user] = currentReputation - _points;
        }
        emit ReputationUpdated(_user, reputation[_user]);
        if (
            reputation[_user] < minValidatorReputation &&
            (validatorStake[_user] > 0 || additionalValidators[_user]) &&
            !blacklistedValidators[_user]
        ) {
            blacklistedValidators[_user] = true;
            emit ValidatorBlacklisted(_user, true);
        }
    }

    function _addValidatorApprovedJob(address validator, uint256 jobId) internal {
        validatorApprovedJobs[validator].push(jobId);
        validatorApprovedJobIndex[validator][jobId] =
            validatorApprovedJobs[validator].length;
    }

    function _addValidatorDisapprovedJob(address validator, uint256 jobId) internal {
        validatorDisapprovedJobs[validator].push(jobId);
        validatorDisapprovedJobIndex[validator][jobId] =
            validatorDisapprovedJobs[validator].length;
    }

    function _removeValidatorApprovedJob(address validator, uint256 jobId) internal {
        uint256 indexPlusOne = validatorApprovedJobIndex[validator][jobId];
        if (indexPlusOne == 0) return;
        uint256[] storage jobsArray = validatorApprovedJobs[validator];
        uint256 lastIndex = jobsArray.length - 1;
        uint256 lastJobId = jobsArray[lastIndex];
        jobsArray[indexPlusOne - 1] = lastJobId;
        validatorApprovedJobIndex[validator][lastJobId] = indexPlusOne;
        jobsArray.pop();
        delete validatorApprovedJobIndex[validator][jobId];
    }

    function _removeValidatorDisapprovedJob(address validator, uint256 jobId) internal {
        uint256 indexPlusOne =
            validatorDisapprovedJobIndex[validator][jobId];
        if (indexPlusOne == 0) return;
        uint256[] storage jobsArray = validatorDisapprovedJobs[validator];
        uint256 lastIndex = jobsArray.length - 1;
        uint256 lastJobId = jobsArray[lastIndex];
        jobsArray[indexPlusOne - 1] = lastJobId;
        validatorDisapprovedJobIndex[validator][lastJobId] = indexPlusOne;
        jobsArray.pop();
        delete validatorDisapprovedJobIndex[validator][jobId];
    }

    /// @notice Allow the employer to reclaim funds if the agent never submits results.
    /// @param _jobId Identifier of the job to timeout.
    function timeoutJob(uint256 _jobId)
        external
        nonReentrant
        whenNotPaused
        jobExists(_jobId)
    {
        Job storage job = jobs[_jobId];
        if (msg.sender != job.employer) revert Unauthorized();
        if (job.status != JobStatus.Open) revert JobNotOpen();
        if (job.assignedAgent == address(0)) revert InvalidJobState();
        if (block.timestamp <= job.assignedAt + job.duration) revert JobNotExpired();

        // Clear any selected validators for the job
        for (uint256 i; i < job.selectedValidators.length; ) {
            address validator = job.selectedValidators[i];
            job.isSelectedValidator[validator] = false;
            unchecked {
                ++i;
            }
        }
        delete job.selectedValidators;

        job.status = JobStatus.Completed;
        totalJobEscrow -= job.payout;
        agiToken.safeTransfer(job.employer, job.payout);

        emit JobTimedOut(_jobId, job.employer, JobStatus.Completed);
    }

    function cancelJob(uint256 _jobId)
        external
        nonReentrant
        jobExists(_jobId)
    {
        Job storage job = jobs[_jobId];
        if (
            msg.sender != job.employer ||
            job.status != JobStatus.Open ||
            job.assignedAgent != address(0)
        ) revert Unauthorized();
        address employer = job.employer;
        uint256 payout = job.payout;
        delete jobs[_jobId];
        totalJobEscrow -= payout;
        agiToken.safeTransfer(employer, payout);
        emit JobCancelled(_jobId);
    }

    /// @notice Finalize a job, distribute payouts, burn tokens and mint the completion NFT.
    /// @dev Invoked when the last validator approval or dispute resolution finalizes a job.
    function _finalizeJobAndBurn(uint256 _jobId) internal jobExists(_jobId) {
        Job storage job = jobs[_jobId];
        if (job.status == JobStatus.Completed) revert JobAlreadyFinalized();
        // Disallow payout without an explicit completion request
        if (
            job.status != JobStatus.CompletionRequested &&
            job.status != JobStatus.Disputed
        ) revert CompletionNotRequested();
        // Ensure burning and payouts occur only after the job meets validation requirements
        if (
            job.status != JobStatus.Disputed &&
            job.validatorApprovals < requiredValidatorApprovals
        ) revert JobNotValidated();
        job.status = JobStatus.Completed;
        totalJobEscrow -= job.payout;
        uint256 completionTime = block.timestamp - job.assignedAt;
        uint256 reputationPoints = calculateReputationPoints(job.payout, completionTime);
        enforceReputationGrowth(job.assignedAgent, reputationPoints);
        uint256 burnAmount =
            (job.payout * burnPercentage) / PERCENTAGE_DENOMINATOR;
        uint256 validatorPayoutTotal =
            (job.payout * validationRewardPercentage) /
            PERCENTAGE_DENOMINATOR;
        uint256 agentPayout = job.payout - burnAmount - validatorPayoutTotal;
        uint256 bonusPercentage =
            getHighestPayoutPercentage(job.assignedAgent);
        if (bonusPercentage > 0) {
            uint256 bonusAmount =
                (agentPayout * bonusPercentage) / PERCENTAGE_DENOMINATOR;
            uint256 maxFundedBonus = burnAmount + validatorPayoutTotal;
            if (bonusAmount > maxFundedBonus) {
                bonusAmount = maxFundedBonus;
            }
            uint256 remaining = bonusAmount;
            if (validatorPayoutTotal >= remaining) {
                validatorPayoutTotal -= remaining;
                remaining = 0;
            } else {
                remaining -= validatorPayoutTotal;
                validatorPayoutTotal = 0;
            }
            if (remaining > 0) {
                if (burnAmount >= remaining) {
                    burnAmount -= remaining;
                } else {
                    burnAmount = 0;
                }
            }
            agentPayout = job.payout - burnAmount - validatorPayoutTotal;
        }

        if (agentPayout + validatorPayoutTotal + burnAmount > job.payout)
            revert PayoutExceedsEscrow();

        uint256 validatorReputationChange =
            calculateValidatorReputationPoints(reputationPoints);
        uint256 correctValidatorCount = job.validatorApprovals;
        address[] memory approvedValidators =
            new address[](correctValidatorCount);
        uint256 approvedIndex = 0;
        uint256 totalSlashed = 0;

        uint256 svLen = job.selectedValidators.length;
        for (uint256 i; i < svLen; ) {
            address validator = job.selectedValidators[i];
            bool committed = job.committed[validator];
            bool revealed = job.revealed[validator];
            if (committed && revealed && job.approvals[validator]) {
                _removeValidatorApprovedJob(validator, _jobId);
                approvedValidators[approvedIndex++] = validator;
                enforceReputationGrowth(validator, validatorReputationChange);
            } else if (committed && revealed && job.disapprovals[validator]) {
                _removeValidatorDisapprovedJob(validator, _jobId);
                uint256 slashAmount =
                    (validatorStake[validator] * slashingPercentage) /
                    PERCENTAGE_DENOMINATOR;
                if (slashAmount > 0) {
                    validatorStake[validator] -= slashAmount;
                    totalValidatorStake -= slashAmount;
                    totalSlashed += slashAmount;
                    emit StakeSlashed(validator, slashAmount);
                }
                enforceReputationPenalty(validator, validatorReputationChange);
            } else if (committed && revealed) {
                _removeValidatorApprovedJob(validator, _jobId);
                _removeValidatorDisapprovedJob(validator, _jobId);
                uint256 slashAmount =
                    (validatorStake[validator] * slashingPercentage) /
                    PERCENTAGE_DENOMINATOR;
                if (slashAmount > 0) {
                    validatorStake[validator] -= slashAmount;
                    totalValidatorStake -= slashAmount;
                    totalSlashed += slashAmount;
                    emit StakeSlashed(validator, slashAmount);
                }
                enforceReputationPenalty(validator, validatorReputationChange);
            } else {
                _removeValidatorApprovedJob(validator, _jobId);
                _removeValidatorDisapprovedJob(validator, _jobId);
                uint256 slashAmount =
                    (validatorStake[validator] * slashingPercentage) /
                    PERCENTAGE_DENOMINATOR;
                if (slashAmount > 0) {
                    validatorStake[validator] -= slashAmount;
                    totalValidatorStake -= slashAmount;
                    totalSlashed += slashAmount;
                    emit StakeSlashed(validator, slashAmount);
                }
                enforceReputationPenalty(validator, validatorReputationChange);
                emit ValidatorSkipped(_jobId, validator, committed, revealed);
            }
            if (pendingCommits[validator] > 0) {
                pendingCommits[validator] -= 1;
            }
            delete job.approvals[validator];
            delete job.disapprovals[validator];
            delete job.commitments[validator];
            delete job.revealed[validator];
            delete job.revealedVotes[validator];
            delete job.committed[validator];
            unchecked {
                ++i;
            }
        }

        delete job.validators;
        for (uint256 i; i < svLen; ) {
            delete job.isSelectedValidator[job.selectedValidators[i]];
            unchecked {
                ++i;
            }
        }
        delete job.selectedValidators;

        if (correctValidatorCount == 0) {
            validatorPayoutTotal = 0;
        }

        uint256 validatorPayout =
            correctValidatorCount > 0
                ? validatorPayoutTotal / correctValidatorCount
                : 0;
        uint256 slashedReward =
            correctValidatorCount > 0
                ? totalSlashed / correctValidatorCount
                : 0;
        uint256 distributedValidator =
            validatorPayout * correctValidatorCount;
        uint256 distributedSlashed =
            slashedReward * correctValidatorCount;
        uint256 leftover =
            (validatorPayoutTotal - distributedValidator) +
            (totalSlashed - distributedSlashed);

        if (burnAmount > 0) {
            if (burnAddress == address(0)) revert BurnAddressNotSet();
            agiToken.safeTransfer(burnAddress, burnAmount);
        }

        if (correctValidatorCount == 0) {
            if (totalSlashed > 0) {
                agiToken.safeTransfer(slashedStakeRecipient, totalSlashed);
            }
        } else {
            uint256 aLen = approvedValidators.length;
            for (uint256 i; i < aLen; ) {
                uint256 reward = validatorPayout + slashedReward;
                if (reward > 0) {
                    agiToken.safeTransfer(approvedValidators[i], reward);
                    emit ValidatorPayout(approvedValidators[i], reward);
                }
                unchecked {
                    ++i;
                }
            }
            if (leftover > 0) {
                agiToken.safeTransfer(slashedStakeRecipient, leftover);
                emit LeftoverTransferred(slashedStakeRecipient, leftover);
            }
        }

        agentPayout = job.payout - burnAmount - validatorPayoutTotal;

        agiToken.safeTransfer(job.assignedAgent, agentPayout);

        uint256 tokenId = nextTokenId++;
        _safeMint(job.employer, tokenId);
        emit NFTIssued(tokenId, job.employer, tokenURI(tokenId));
        emit JobFinalizedAndBurned(
            _jobId,
            job.assignedAgent,
            job.employer,
            agentPayout,
            burnAmount
        );

        emit JobCompleted(
            _jobId,
            job.assignedAgent,
            reputationPoints,
            JobStatus.Completed
        );
        emit ReputationUpdated(job.assignedAgent, reputation[job.assignedAgent]);
    }

    function listNFT(uint256 tokenId, uint256 price)
        external
        whenNotPaused
        nonReentrant
    {
        if (ownerOf(tokenId) != msg.sender) revert Unauthorized();
        if (price == 0) revert InvalidParameters();
        if (listings[tokenId].isActive) revert ListingAlreadyActive();
        listings[tokenId] = Listing(tokenId, msg.sender, price, true);
        emit NFTListed(tokenId, msg.sender, price);
    }

    function purchaseNFT(uint256 tokenId)
        external
        whenNotPaused
        nonReentrant
    {
        Listing storage listing = listings[tokenId];
        if (!listing.isActive) revert InvalidJobState();
        address seller = listing.seller;
        if (seller == msg.sender) revert SelfPurchase();
        uint256 price = listing.price;
        delete listings[tokenId];
        agiToken.safeTransferFrom(msg.sender, seller, price);
        _safeTransfer(seller, msg.sender, tokenId, "");
        emit NFTPurchased(tokenId, msg.sender, price);
    }

    function delistNFT(uint256 tokenId)
        external
        whenNotPaused
        nonReentrant
    {
        Listing storage listing = listings[tokenId];
        if (!listing.isActive || listing.seller != msg.sender) revert Unauthorized();
        delete listings[tokenId];
        emit NFTDelisted(tokenId);
    }

    function _verifyOwnership(address claimant, string memory subdomain, bytes32[] calldata proof, bytes32 rootNode) internal returns (bool) {
        bytes32 leaf = keccak256(abi.encodePacked(claimant));
        if (
            MerkleProof.verifyCalldata(
                proof,
                rootNode == agentRootNode
                    ? agentMerkleRoot
                    : validatorMerkleRoot,
                leaf
            )
        ) {
            emit OwnershipVerified(claimant, subdomain);
            return true;
        }

        bytes32 subnode = keccak256(abi.encodePacked(rootNode, keccak256(bytes(subdomain))));
        try nameWrapper.ownerOf(uint256(subnode)) returns (address actualOwner) {
            if (actualOwner == claimant) {
                emit OwnershipVerified(claimant, subdomain);
                return true;
            }
        } catch Error(string memory reason) {
            emit RecoveryInitiated(reason);
        } catch {
            emit RecoveryInitiated("NameWrapper call failed without a specified reason.");
        }

        address resolverAddress = ens.resolver(subnode);
        if (resolverAddress != address(0)) {
            Resolver resolver = Resolver(resolverAddress);
            try resolver.addr(subnode) returns (address payable resolvedAddress) {
                if (resolvedAddress == claimant) {
                    emit OwnershipVerified(claimant, subdomain);
                    return true;
                }
            } catch {
                emit RecoveryInitiated("Resolver call failed without a specified reason.");
            }
        } else {
            emit RecoveryInitiated("Resolver address not found for node.");
        }

        return false;
    }

    /// @notice Replace the entire validator pool.
    /// @param validators New list of validator addresses.
    function setValidatorPool(address[] calldata validators) external onlyOwner {
        if (validators.length == 0) revert InvalidParameters();
        if (validators.length > maxValidatorPoolSize) revert ValidatorPoolFull();
        for (uint256 i; i < validators.length; ) {
            address v = validators[i];
            if (v == address(0)) revert InvalidAddress();
            for (uint256 j = i + 1; j < validators.length; ) {
                if (v == validators[j]) revert DuplicateValidator();
                unchecked {
                    ++j;
                }
            }
            unchecked {
                ++i;
            }
        }
        uint256 currentLength = validatorPool.length;
        for (uint256 i; i < currentLength; ) {
            address vOld = validatorPool[i];
            delete isValidatorInPool[vOld];
            delete validatorPoolIndex[vOld];
            unchecked {
                ++i;
            }
        }
        delete validatorPool;
        uint256 newLen = validators.length;
        for (uint256 i; i < newLen; ) {
            address v = validators[i];
            validatorPool.push(v);
            isValidatorInPool[v] = true;
            validatorPoolIndex[v] = validatorPool.length - 1;
            unchecked {
                ++i;
            }
        }
        emit ValidatorPoolSet(validators);
    }

    function addAdditionalValidator(address validator) external onlyOwner {
        if (validator == address(0)) revert InvalidAddress();
        additionalValidators[validator] = true;
        if (!isValidatorInPool[validator]) {
            if (validatorPool.length >= maxValidatorPoolSize) {
                revert ValidatorPoolFull();
            }
            validatorPoolIndex[validator] = validatorPool.length;
            validatorPool.push(validator);
            isValidatorInPool[validator] = true;
        }
        emit AdditionalValidatorAdded(validator);
    }

    function removeAdditionalValidator(address validator) external onlyOwner {
        if (
            !(additionalValidators[validator] || isValidatorInPool[validator])
        ) revert ValidatorNotFound();
        additionalValidators[validator] = false;
        if (isValidatorInPool[validator]) {
            uint256 index = validatorPoolIndex[validator];
            uint256 lastIndex = validatorPool.length - 1;
            if (index != lastIndex) {
                address lastValidator = validatorPool[lastIndex];
                validatorPool[index] = lastValidator;
                validatorPoolIndex[lastValidator] = index;
            }
            validatorPool.pop();
            delete isValidatorInPool[validator];
            delete validatorPoolIndex[validator];
        }
        emit ValidatorRemoved(validator);
    }

    function addAdditionalAgent(address agent) external onlyOwner {
        if (agent == address(0)) revert InvalidAddress();
        additionalAgents[agent] = true;
        emit AdditionalAgentAdded(agent);
    }

    function removeAdditionalAgent(address agent) external onlyOwner {
        additionalAgents[agent] = false;
        emit AdditionalAgentRemoved(agent);
    }

    /// @notice Deposit $AGI to satisfy the staking requirement for validators.
    /// @param amount Quantity of tokens to stake.
    /// @dev Validators may top up their stake in multiple transactions; validation
    ///      functions enforce that the total meets `stakeRequirement` before voting.
    function stake(uint256 amount) external whenNotPaused nonReentrant {
        if (amount == 0) revert InvalidAmount();
        agiToken.safeTransferFrom(msg.sender, address(this), amount);
        validatorStake[msg.sender] += amount;
        totalValidatorStake += amount;
        emit StakeDeposited(msg.sender, amount);
    }

    function withdrawStake(uint256 amount) external nonReentrant {
        if (amount == 0 || amount > validatorStake[msg.sender]) revert InvalidAmount();
        if (
            validatorApprovedJobs[msg.sender].length != 0 ||
            validatorDisapprovedJobs[msg.sender].length != 0
        ) revert PendingOrDisputedJob();
        if (pendingCommits[msg.sender] != 0) revert PendingCommitments();
        validatorStake[msg.sender] -= amount;
        totalValidatorStake -= amount;
        if (
            validatorStake[msg.sender] != 0 &&
            validatorStake[msg.sender] < stakeRequirement
        ) revert StakeBelowRequirement();
        agiToken.safeTransfer(msg.sender, amount);
        emit StakeWithdrawn(msg.sender, amount);
    }

    /// @notice Withdraw AGI tokens held by the contract.
    /// @param amount Amount of AGI to withdraw.
    function withdrawAGI(uint256 amount) external onlyOwner nonReentrant {
        uint256 balance = agiToken.balanceOf(address(this));
        uint256 locked = totalJobEscrow + totalValidatorStake;
        if (amount == 0 || balance <= locked || amount > balance - locked)
            revert InvalidAmount();
        agiToken.safeTransfer(msg.sender, amount);
        emit AGIWithdrawn(msg.sender, amount);
    }

    /// @notice Determine if a user meets the premium reputation threshold.
    /// @param user Address being evaluated.
    /// @return hasAccess True if the user can access premium features.
    function canAccessPremiumFeature(address user) public view returns (bool hasAccess) {
        // solhint-disable-next-line gas-strict-inequalities
        return reputation[user] >= premiumReputationThreshold;
    }

    /// @notice Contribute AGI tokens to the communal reward pool.
    /// @param amount Amount of AGI to contribute.
    function contributeToRewardPool(uint256 amount) external whenNotPaused nonReentrant {
        if (amount == 0) revert InvalidAmount();
        agiToken.safeTransferFrom(msg.sender, address(this), amount);
        emit RewardPoolContribution(msg.sender, amount);
    }

    /// @notice Register or update an AGI NFT type that grants bonus payouts.
    /// @param nftAddress Address of the qualifying NFT collection.
    /// @param payoutPercentage Bonus percentage in basis points applied to job payouts for holders of the NFT.
    function addAGIType(address nftAddress, uint256 payoutPercentage) external onlyOwner {
        if (nftAddress == address(0) || payoutPercentage == 0 || payoutPercentage > PERCENTAGE_DENOMINATOR) {
            revert InvalidAGITypeParameters();
        }

        bool exists = false;
        uint256 length = agiTypes.length;
        for (uint256 i; i < length; ) {
            if (agiTypes[i].nftAddress == nftAddress) {
                agiTypes[i].payoutPercentage = payoutPercentage;
                exists = true;
                break;
            }
            unchecked {
                ++i;
            }
        }
        if (!exists) {
            if (length >= MAX_AGI_TYPES) {
                revert MaxAGITypesReached();
            }
            agiTypes.push(AGIType({ nftAddress: nftAddress, payoutPercentage: payoutPercentage }));
        }

        emit AGITypeUpdated(nftAddress, payoutPercentage);
    }

    /// @notice Remove an AGI NFT type.
    /// @param nftAddress Address of the NFT collection to remove.
    function removeAGIType(address nftAddress) external onlyOwner {
        uint256 length = agiTypes.length;
        for (uint256 i; i < length; ) {
            if (agiTypes[i].nftAddress == nftAddress) {
                agiTypes[i] = agiTypes[length - 1];
                agiTypes.pop();
                emit AGITypeRemoved(nftAddress);
                return;
            }
            unchecked {
                ++i;
            }
        }
        revert AGITypeNotFound();
    }

    /// @notice Determine the highest AGI payout bonus available to an agent.
    /// @param agent Address being queried.
    /// @return highestPercentage Maximum bonus percentage in basis points among held AGI types.
    function getHighestPayoutPercentage(address agent) public view returns (uint256 highestPercentage) {
        uint256 len = agiTypes.length;
        for (uint256 i; i < len; ) {
            try IERC721(agiTypes[i].nftAddress).balanceOf(agent) returns (uint256 bal) {
                if (bal > 0 && agiTypes[i].payoutPercentage > highestPercentage) {
                    highestPercentage = agiTypes[i].payoutPercentage;
                }
            } catch {
                // treat as zero balance
            }
            unchecked {
                ++i;
            }
        }
    }
}

